---
title: "5_Post Review"
author: "Simon"
date: "2024-01-09"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, 
                      warning = F)
options(scipen=999)

rm(list = ls())

library(tidyverse)
library("ggsci")
library(here)
library(knitr)
library(stargazer)
library(parallel)
library(RColorBrewer)

if(!(c('Fishlife')  %in% installed.packages())){
  devtools::install_github("james-thorson/FishLife")
}
if(!(c('tinytable') %in% installed.packages())){
  devtools::install_github("vincentarelbundock/tinytable")
}

library(tinytable)
library(FishLife)
library(kableExtra)

Latex = T
font_ = 'Helvetica'
color_growth = 'black'
color_vertical_monopoly = '#B22222'
color_bertrand = '#1f78b4'
color_cournot = '#248721'
palette_ = c(color_growth, color_vertical_monopoly, color_bertrand, color_cournot)
```

# Model with linear quadratic costs

Load data from the Google Drive folder, and store : 

* `params_sensitivity_lq.csv` in `data\inputs`

* `steady_states.csv`, `profitability.csv` and `bioeconomic_performance.csv` in a dedicated folder : `data\outputs\sensitivity_analysis_lq\`

This first code chunk creates the folder if needed, and checks if data is at the right place. 

```{r, architecture}
if(!dir.exists(here('data', 'outputs', 'sensitivity_analysis_lq'))){
  dir.create(here('data','outputs', 'sensitivity_analysis_lq'))
  print('Folder created as data/outputs/sensitivity_analysis_lq :')
}

if(!file.exists(here('data', 'outputs', 'sensitivity_analysis_lq', 'steady_states.csv'))){
  print('Please put steady_states.csv, profitability.csv and bioeconomic_performances.csv in folder')
}else{
  print('Architecture and data are up to date')
}

```

## I. Recover W
### A. Load data
Use the same data as in `1_Parameters.rmd`.
```{r, Load data}
dat_p = read.csv(here("data","inputs","dat_p.csv")) #Price-quantity data (OG Paper)
dat_p = dat_p %>%
  mutate(price_buche = g*p,
         price_kg = p*1000, 
         price_buche_kg = price_buche*1000)


dat_b = read.csv(here('data', 'inputs', "totoaba_biomass_catch_20230516.csv")) %>% 
  rename(y = X) %>% 
  rename(b = Biomass..Tonnes.) %>% 
  rename(c = Catch..Tonnes.)

w_par = read.csv(here("data", 'inputs', "w_par.csv"))
v_par = read.csv(here("data", 'inputs', "v_par.csv")) 

sources = read.csv(here("data", 'inputs', "sources.csv"))

```


### B. Calculate W
Calculate costs of poaching using the same method as in `1_Parameters.rmd`. 
```{r calculating cost of poaching}

# W parameter, proportional increase in cost per unit (trip)

#Step one, get all annual operating costs
# Goal is to calculate cost per vessel trip (we have total fleet days per year which is number of vessels * fishing days per month)
# First calculate total annual costs for the entire fleet

w_par_ops <- w_par %>% 
  mutate(cost_crew_earnings = (totoaba_year * price_fishers_per_totoaba * monthly_earnings_paid)) %>% 
  mutate(cost_food_fuel = (foodfuel_day * total_fleet_days_year)) %>% 
  mutate(cost_gear = total_fleet_days_year*(gear_loss_day*gear_replacement)) %>% 
  mutate(revenue_per_month = (totoaba_year*(price_fishers_per_totoaba)) - (cost_crew_earnings-cost_food_fuel-cost_gear))

# Next, divide by total fishing days per year

w_par_val <- w_par_ops %>% 
  select(vessels, totoaba_day, total_fleet_days_year,cost_crew_earnings,cost_food_fuel,cost_gear,bribes_year,revenue_per_month) %>% 
  mutate(cost_per_trip = (cost_crew_earnings + cost_food_fuel + cost_gear + bribes_year)/total_fleet_days_year) 

#Adding in gear and vessel confiscation (calculated as a shared cost applied to the entire fleet)

w_pal_val_conf <- w_par_val %>%
  add_column(net_confs_cost_fleetday=664000/1920) %>% #Total cost as a proportion of reported confiscations averaged over the year (1,920 fishing trips total). 5,720 nets in the water each year (each vessel sets 2-3 nets), and 0.07 of those nets are confiscated (we know that there are 415 gear confiscation events each year). So if we assume that each net costs $1,600, then our total cost to the fleet is $664,000.
  add_column(vessel_confs_cost_fleetday=1230000/1920) %>% #Total cost as a proportion of reported vessel seizures averaged over the year (1,920 fishing trips total). There are 150 boats in total each year, and 0.546 are confiscated (there are 82 confiscations a year). So we assume each boat is worth $15,000, and therefore the total cost to the fleet is $1,230,000.
  add_column(fines_cost_fleetday=81675/1920) %>% #Total cost as a proportion of reported vessel seizures averaged over the year (1,920 fishing trips total). There are 11 arrests/convictions where people are fined $7,425/event, which would add an additional cost of $42.54.
  mutate(cost_per_trip = (cost_crew_earnings + cost_food_fuel + cost_gear + bribes_year)/total_fleet_days_year) %>% 
  mutate(cost_per_trip_wconf = cost_per_trip + net_confs_cost_fleetday + vessel_confs_cost_fleetday + fines_cost_fleetday)

costs = w_pal_val_conf %>% 
  select(cost_per_trip_wconf)%>%
  unique()%>%
  drop_na()%>%
  pull()%>%
  sort()
# Final estimates of cost per trip (W)

W_low = costs[1] #Low Season 
W_mid = costs[2] # Mid Season
W_high = costs[3] # High Season

max_E = sum(w_par$total_fleet_days_year)

```

### C. Attempt to recover W1 and W2:

Notice that we operate under the condition that the marginal cost equals the average cost to find $W$. Now, we are trying to find a linear quadratic function in effort : 
$$
W_1 + 2W_2 E_{hist} = AC
$$

Given the lack of accurate data, we need to run a variety of analysis such that $W_1>0$, $W_2>0$ and $W_1 - AC + 2W_2  E_{Hist} = 0$, eg $W_2 = \frac{AC - W1}{2E_{Hist}}$.

```{r, recover W1 W2}
W_lq = data.frame(0,0,0,0)
colnames(W_lq) = c('Cost', 'W1', 'W2','W_mid')

for(cost in costs){
  W1 = quantile(seq(0, cost), probs = seq(0,1,.1))
  W2 = rev(quantile((cost - W1)/(2*max_E), probs = seq(0,1,.1)))
  W_mid = cost/(2*max_E)
  W_storage = data.frame(rep(cost, length(W1)), W1, W2, rep(W_mid, length(W1)))
  

  colnames(W_storage) = colnames(W_lq)
  W_lq = rbind(W_lq, W_storage)
}

W_lq = W_lq %>%
  cbind(quantiles = rownames(W_lq))%>%
  subset(W1>0)

to_keep = function(x){
  return(strsplit(x, '%')[[1]][1])
}

W_lq['quantiles'] = apply(W_lq['quantiles'],1, to_keep)

```




```{r, Load Params}
calibration = read.csv(here("data", 'outputs', "calibration_params.csv"))

for(i in 1:nrow(calibration)){
  assign(calibration$params[i], calibration$value[i])
}  


# Build the 2nd order parameters from parameter list
  # Differentiate parameters for Wild and Farmed inverse demands
alpha_w = alpha
alpha_f = alpha
beta_w = beta
beta_f = beta
  # Demand functions parameters
e   = gamma/(beta_w*beta_f - (gamma^2))
a_f = (alpha_f*beta_w - alpha_w*gamma)/(beta_w*beta_f - (gamma^2))
a_w = (alpha_w*beta_f - alpha_f*gamma)/(beta_w*beta_f - (gamma^2))
b_f = beta_f/(beta_w*beta_f - (gamma^2))
b_w = beta_w/(beta_w*beta_f - (gamma^2))

calibration %>% 
  select(-X)%>%
  mutate(value = round(value,2))%>%
  kable(row.names = F)

avg_toto_weight = 25.7
```

## II. Define functions
Define function where variable is either `x` i.e population stock, or `s` i.e price paid to poachers. All the parameters take default values specified in the global environment.  

* `growth(x, ...)` : logistic growth function, yields growth of population (in metric tons) 

* `pt_harvest(x,...)` : harvest (in metric tons) when trader is price taker

* `monop_harvest(x, ...)`: harvest (in metric tons) when trader is a monopolist

* `monop_harvest_lq(x, ...)`: harvest (in metric tons) when trader is a monopolist and cost structure is linear quadratic

* `cournot_harvest(x, ...)`, `bertrand_harvest(x, ...)`: harvest (in metric tons) when trader and farmer compete in *Cournot*, i.e, set quantities strategically, and *Bertrand*, i.e, set prices strategically. 

* `cournot_harvest_lq(x, ...)`, `bertrand_harvest_lq(x, ...)` : harvest  (in metric tons) when trader and farmer compete in *Cournot* i.e, set quantities strategically, and *Bertrand* i.e, set prices strategically and cost structure is linear quadratic

* `price_poachers_cournot(x, ...)`, `price_poachers_bertrand(x, ...)`: price paid to poachers (in USD/metric tons) when trader and farmer compete in *Cournot* and *Bertrand*

* `cournot_farmed(s, ...)`, `bertrand_farmed(s, ...)`: quantity farmed (in metric tons) when trader and farmer compete in *Cournot* and *Bertrand*


```{r}
growth = function(x, 
                  k.=k, 
                  r.=r){
  y = r.*x*(1-x/k.)
  return(y)
}

# I. Price taker
pt_harvest = function(x, 
                      alpha. = alpha, 
                      beta. = beta, 
                      W. = W_mid, 
                      c. = c, 
                      sigma. = sigma){
  y = ((alpha.-c.) * x^2 * sigma.^2)/(4*W. + beta. * sigma.^2 * x^2)
  return(y)
}

# II. Monopoly
monop_harvest = function(x, 
                         alpha. = alpha, 
                         c. = c, 
                         sigma. = sigma, 
                         beta. = beta, 
                         W. = W_mid){
 y = ((alpha. - c.)*sigma.^2 * x^2) / (2*beta.* sigma.^2 * x^2 + 2*W.)
 return(y)
}

monop_harvest_lq = function(x,
                            alpha. = alpha, 
                            c. = c, 
                            sigma. = sigma, 
                            beta. = beta,
                            W1. = W1,
                            W2. = W2){
  y = (sigma.^2 * x^2 * (alpha. - c.) - W1.*sigma.*x)/(2*(beta.*sigma.^2 * x^2 + W2.))
  return(y)
}


# III. Cournot

cournot_harvest = function(x, 
                             alpha_f. = alpha_f, 
                             alpha_w. = alpha_w, 
                             beta_f. = beta_f, 
                             beta_w. = beta_w, 
                             gamma. = gamma, 
                             sigma. = sigma, 
                             c. = c, 
                             v. = v, 
                             W. = W_mid){
  y = ((sigma.^2)*(x^2)*(2*beta_f.*(alpha_w. - c.) - gamma.*(alpha_f. - v.)))/(4*beta_f.*W. + (sigma.^2)*(x^2)*(4*beta_f.*beta_w. - (gamma.^2)))
  return(y)
}

cournot_harvest_lq = function(x, 
                              alpha_f. = alpha_f, 
                              alpha_w. = alpha_w, 
                              beta_f. = beta_f, 
                              beta_w. = beta_w, 
                              gamma. = gamma, 
                              sigma. = sigma, 
                              c. = c, 
                              v. = v, 
                              W1. = W1, 
                              W2. = W2){
 y = ((2*beta_f. * (alpha_w. - c.) - gamma. * (alpha_w. -v.))*sigma.^2 * x^2 - 2*beta_f.*W1.*sigma.*x)/(4*beta_f.*W2. + (4*beta_f.*beta_w. - gamma.^2)*sigma.^2 * x^2)
 return(y)
}

price_poachers_cournot = function(x,
                                  alpha_f. = alpha_f, 
                                  alpha_w. = alpha_w, 
                                  beta_f. = beta_f, 
                                  beta_w. = beta_w, 
                                  gamma. = gamma, 
                                  sigma. = sigma, 
                                  c. = c, 
                                  v. = v, 
                                  W. = W_mid){
  y = (2*W.*(2*beta_f.*(alpha_w. - c.) - gamma.*(alpha_f. - v.)))/((sigma.^2)*(x^2)*(4*beta_f.*beta_w. - gamma.^2) + 4*beta_f.*W.)
  return(y)
}

cournot_farmed = function(s, 
                            alpha_f. = alpha_f, 
                            alpha_w. = alpha_w, 
                            beta_f. = beta_f, 
                            beta_w. = beta_w, 
                            gamma. = gamma, 
                            sigma. = sigma, 
                            c. = c, 
                            v. = v){
  y = (2 * beta_w. * (alpha_f. - v.) - gamma.* (alpha_w. - (s + c.)) )/(4*beta_w.*beta_f. - gamma.^2)
  return(y)
}

# IV. Bertrand

price_poachers_bertrand = function(x, 
                                   a_f. = a_f, 
                                   a_w. = a_w, 
                                   b_f. = b_f, 
                                   b_w. = b_w, 
                                   e.  = e, 
                                   c. = c, 
                                   v. = v, 
                                   sigma. = sigma, 
                                   W. = W_mid){
  y = (2*W.*b_w.*( b_f.*(2*a_w. + e.*v.) + c.*((e.^2) - 2*b_f.*b_w.) + e.*a_f.))/((sigma.^2)*(x^2)*(4*b_f.*b_w. - (e.^2)) + 2*W.*b_w.*(2*b_w.*b_f. - (e.^2)))
  return(y)
}

bertrand_harvest = function(x,
                              sigma. = sigma, 
                              a_f. = a_f, 
                              a_w. = a_w, 
                              b_f. = b_f, 
                              b_w. = b_w, 
                              e. = e, 
                              v. = v, 
                              c. = c, 
                              W. = W_mid){
  y = ((sigma.^2)*(x^2)*b_w.*(b_f.*(2*a_w.+e.*v.) + c.*((e.^2)- 2*b_f.*b_w.) + e.*a_f.))/((sigma.^2)*(x^2)*(4*b_w.*b_f. - (e.^2)) + 2*W.*b_w.*(2*b_f.*b_w. - (e.^2)))
  return(y)
}

bertrand_harvest_lq = function(x,
                               sigma. = sigma, 
                               a_f. = a_f, 
                               a_w. = a_w, 
                               b_f. = b_f, 
                               b_w. = b_w, 
                               e. = e, 
                               v. = v, 
                               c. = c, 
                               W1. = W1, 
                               W2. = W2){
  y1 = b_w.*(sigma.^2 * x^2 *((2*a_w. +e.*v.)*b_f. + e.*a_f.) + (c. + W1. * sigma. * b_w. * x)*(e.^2 - 2*b_w. *b_f.))
  y2 = 2*W2.*b_w.*(2*b_f.* b_w. - e.^2) + (4*b_f.*b_w. - e.^2)*sigma.^2*x^2
  z = y1*y2
  return(z)
}

price_poacher_bertrand_lq = function(x,
                               sigma. = sigma, 
                               a_f. = a_f, 
                               a_w. = a_w, 
                               b_f. = b_f, 
                               b_w. = b_w, 
                               e. = e, 
                               v. = v, 
                               c. = c, 
                               W1. = W1, 
                               W2. = W2){
  y = 2*b_w.*W2.*((2*a_w. + e.*v.)*b_f. + e.*a_f. + c.*(e.^2 - b_f.*b_w.)) + W1.*sigma.*x*(4*b_f.*b_w. - e.^2)
  z = sigma.^2 * x^2 * (4*b_w.*b_f. - e.^2) + 4*b_w.*W2.*(2*b_f.*b_w - e.^2)
  result = y/z
  return(result)
}

composite_bertrand_lq = function(x,
                               sigma. = sigma, 
                               a_f. = a_f, 
                               a_w. = a_w, 
                               b_f. = b_f, 
                               b_w. = b_w, 
                               e. = e, 
                               v. = v, 
                               c. = c, 
                               W1. = W1, 
                               W2. = W2){
  y = b_w. * ((2*a_w. +e.*v.)*b_f. + e.*a_f. + (price_poacher_bertrand_lq(x)+c.)*(e.^2 - 2*b_w.*b_f))/(4*b_f.*b_w. - e.^2)
  return(y)
}

bertrand_farmed = function(s, 
                             a_f. = a_f, 
                             a_w. = a_w, 
                             b_f. = b_f, 
                             b_w. = b_w, 
                             e. = e, 
                             c. = c, 
                             v. = v){
  y = b_f. *(2*b_w.*a_f. + v.*(e.^2 - 2*b_w.*b_f.) + e.*(a_w. + (s+c.)*b_w.))/(4*b_f.*b_w. - e.^2)
  return(y)
}

```

## III. Generate results

Generate results saved at `~/data/outputs/results_post_review.csv` :

* Set cost variables using `W_lq`: each row corresponds to a cost parameter $W$, $W_1$ and $W_2$
```{r, Results}
# Initiate data storage
storage = data.frame(0,0,0,0,0,0,0,0)
colnames(storage) = c('x','names','values','AC', 'W_mid', 'W1', 'W2',"quantile")

# Run model for every W configuration
for(row in 1:nrow(W_lq)){
  W_mid = W_lq[row,4]
  W1 = W_lq[row,2]
  W2 = W_lq[row,3]
  quantile = W_lq[row,5]
  
  result1 = data.frame(x = seq(1,k,.5 ))%>%
    mutate(growth= growth(x),
           # Harvests with quadratic and linear-quadratic costs
           monop_harvest = monop_harvest(x),
           monop_harvest_lq = monop_harvest_lq(x),
           cournot_harvest = cournot_harvest(x),
           cournot_harvest_lq = cournot_harvest_lq(x),
           bertrand_harvest = bertrand_harvest(x),
           bertrand_harvest_lq = composite_bertrand_lq(x),
           # Steady states
           ss_monop = monop_harvest - growth, 
           ss_monop_lq = monop_harvest_lq - growth, 
           ss_cournot = cournot_harvest - growth, 
           ss_cournot_lq = cournot_harvest_lq - growth,
           ss_bertrand = bertrand_harvest - growth, 
           ss_bertrand_lq = bertrand_harvest_lq - growth,
           # Prices
           price_poachers_lq = price_poacher_bertrand_lq(x),
           price_poachers_bertrand = price_poachers_bertrand(x))
  
  # Put data in long format
  errr = result1 %>% 
    pivot_longer(-x, names_to = 'names', values_to = 'values')%>%
    subset(names %in% c('ss_monop',
                        'ss_monop_lq',
                        'ss_cournot',
                        'ss_cournot_lq',
                        'ss_bertrand',
                        'ss_bertrand_lq'))%>%
    subset(values > -.1)%>%
    subset(values < .1)%>%
    mutate(AC = W_lq[row,1],
           W_mid = W_mid, 
           W1 = W1, 
           W2 = W2,
           quantile = quantile)
  # Store
  storage = rbind(storage, errr)
}


# Goal is to format to have only 1 steady state value : filter out the points around the steady states. 
cost = unique(storage$AC)[2]

# Initiate storage
final_dat = data.frame(0,0,0,0,0,0,0,0,0)
colnames(final_dat) = c(colnames(storage), 'lag_sign')

# Mutate ac_quantile to have 1 combination to scan through
storage = storage %>%
  mutate(ac_quantile = paste0(AC,quantile))

# Loop over name and ac_quantile combination
for(name in unique(storage$names)){
  for(ac_quant in unique(storage$ac_quantile)){
    study = storage %>%
      subset(names == name)%>%
      subset(ac_quantile == ac_quant)%>%     # Subset data 
      mutate(lag_sign = c(0, diff(sign(values))), # Mutate to get sign change and value of steady state change
             lag_val = c(0, diff(x)))
    # Define cut vector to scan through each zone : cuts are defined as jumps in x value 
      cuts_ = which(study$lag_val>5 | study$lag_val < -5) - 1
      cuts_ = c(0,cuts_, nrow(study))
    # Use cuts vector to scan through
    for(cut in 1:(length(cuts_)-1)){
      lb_ = cuts_[cut]+1
      ub_ = cuts_[cut+1]
    
      to_check = study[lb_: ub_,]%>%
        subset(lag_sign !=0)%>%
        subset(lag_val>0)%>% # Keep only when the lag value is positive : otherwise, it means a change in sequence or type of equilibrium
        select(-c(lag_val, ac_quantile))
    
      final_dat = rbind(final_dat, to_check)
    }
  }
  
}

# Eventually, tell if equilibrium is stable using lag_sign 
final_dat = final_dat %>%
  subset(AC>0)%>%
  mutate(Stable = ifelse(lag_sign>0,'Stable', 'Unstable'))

# Save

write.csv(final_dat, here('data', 'outputs', 'results_post_review.csv'))
              
```



### Graph outputs : 

First, illustrate the new equilibria with the same $W$ value and the middle point solution for $W_1$ and $W_2$ in the linear quadratic cost of effort specification. 

```{r, New equilibrium}
W_mid    = W_lq[21,4]
W1       = W_lq[21,2]
W2       = W_lq[21,3]
quantile = W_lq[21,5]

result1 = data.frame(x = seq(1,k,.5 ))%>%
  mutate(growth= growth(x),
         monop_harvest = monop_harvest(x),
         monop_harvest_lq = monop_harvest_lq(x),
         cournot_harvest = cournot_harvest(x),
         cournot_harvest_lq = cournot_harvest_lq(x),
         bertrand_harvest = bertrand_harvest(x),
         bertrand_harvest_lq = composite_bertrand_lq(x),
         ss_monop = monop_harvest - growth, 
         ss_monop_lq = monop_harvest_lq - growth, 
         ss_cournot = cournot_harvest - growth, 
         ss_cournot_lq = cournot_harvest_lq - growth,
         ss_bertrand = bertrand_harvest - growth, 
         ss_bertrand_lq = bertrand_harvest_lq - growth,
         price_poachers_lq = price_poacher_bertrand_lq(x),
         price_poachers_bertrand = price_poachers_bertrand(x))
# Format:
renamer= function(x){
  if(x %in% c('monop_harvest', 'monop_harvest_lq')){
    return('Vertical Monopoly')
  }else if(x %in% c('cournot_harvest', 'cournot_harvest_lq')){
    return('Quantity adjustment')
  }else if(x %in% c('bertrand_harvest', 'bertrand_harvest_lq')){
    return('Price setting')
  }else if(x %in% c('growth')){
    return('Growth')
  }
}

renamer2 = function(x){
  checker = strsplit(x, '_')[[1]]
  if(length(checker)<3){
    return('Quadratic cost')
  }else{
    return('Linear quadratic cost')
  }
}

rounder = function(x){
  return(max(0,x))
}

dat_ = result1 %>%
  pivot_longer(-x, 
               values_to = 'values', 
               names_to = 'names')%>%
  subset(names %in% c('growth', 
                      'monop_harvest', 
                      'monop_harvest_lq', 
                      'cournot_harvest',
                      'cournot_harvest_lq', 
                      'bertrand_harvest', 
                      'bertrand_harvest_lq'))
dat_$new_names = sapply(dat_$names, renamer)
dat_$values2 = sapply(dat_$values, rounder)
dat_$cost_structure = sapply(dat_$names, renamer2)

dat_%>%
  subset(x %%2 == 0)%>%
  ggplot(aes(x = x,
             y = values2, 
             color = new_names))+
  geom_line(aes(linetype = cost_structure))+
  scale_linetype_manual(values=c("solid", "twodash"))+
  scale_color_manual(values = palette_)+
  theme_bw()+
  guides(
    color = guide_legend(
      title = " ",  # Title for the first column
      ncol = 2              # Number of columns
    ),
    linetype = guide_legend(
      title = ' ',
      ncol = 2
    ))+
  xlab('Population')+
  ylab('Harvest')+
  theme(legend.position = 'bottom',
        strip.text.x  = element_text(family = font_) ,
        axis.title.x  = element_text(family = font_),
        axis.text = element_text(family = font_),
        axis.title.y  = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))


```

To understand the impact of different $W_1$ & $W_2$ divides : 

```{r, understand different W}
store = data.frame(matrix(nrow = 0, ncol= ncol(result1)+1))
colnames(store)= c(colnames(result1), 'quantile')

for(xx in c(21, 25, 29)){
  W_mid    = W_lq[xx,4]
  W1       = W_lq[xx,2]
  W2       = W_lq[xx,3]
  quantile = W_lq[xx,5]
  
  result1 = data.frame(x = seq(1,k,.5 ))%>%
    mutate(growth= growth(x),
           monop_harvest = monop_harvest(x),
           monop_harvest_lq = monop_harvest_lq(x),
           cournot_harvest = cournot_harvest(x),
           cournot_harvest_lq = cournot_harvest_lq(x),
           bertrand_harvest = bertrand_harvest(x),
           bertrand_harvest_lq = composite_bertrand_lq(x),
           ss_monop = monop_harvest - growth, 
           ss_monop_lq = monop_harvest_lq - growth, 
           ss_cournot = cournot_harvest - growth, 
           ss_cournot_lq = cournot_harvest_lq - growth,
           ss_bertrand = bertrand_harvest - growth, 
           ss_bertrand_lq = bertrand_harvest_lq - growth,
           price_poachers_lq = price_poacher_bertrand_lq(x),
           price_poachers_bertrand = price_poachers_bertrand(x),
           quantile = paste0('W1 =', round(W1,1), ' & W2 = ', round(W2,1)))
  store = rbind(store, 
                result1)
}

store$quantile = factor(store$quantile, levels = c("W1 =12947.4 & W2 = 0.4",
                                                   "W1 =7193 & W2 = 1.9",
                                                   "W1 =1438.6 & W2 = 3.4"))

# Format:
renamer= function(x){
  if(x %in% c('monop_harvest', 'monop_harvest_lq')){
    return('Vertical Monopoly')
  }else if(x %in% c('cournot_harvest', 'cournot_harvest_lq')){
    return('Quantity adjustment')
  }else if(x %in% c('bertrand_harvest', 'bertrand_harvest_lq')){
    return('Price setting')
  }else if(x %in% c('growth')){
    return('Growth')
  }
}

renamer2 = function(x){
  checker = strsplit(x, '_')[[1]]
  if(length(checker)<3){
    return('Quadratic cost')
  }else{
    return('Linear quadratic cost')
  }
}

rounder = function(x){
  return(max(0,x))
}

dat_ = store %>%
  pivot_longer(-c(x,quantile), 
               values_to = 'values', 
               names_to = 'names')%>%
  subset(names %in% c('growth', 
                      'monop_harvest', 
                      'monop_harvest_lq', 
                      'cournot_harvest',
                      'cournot_harvest_lq', 
                      'bertrand_harvest', 
                      'bertrand_harvest_lq'))
dat_$new_names = sapply(dat_$names, renamer)
dat_$values2 = sapply(dat_$values, rounder)
dat_$cost_structure = sapply(dat_$names, renamer2)

p = dat_%>%
  subset(x %% 2 == 0)%>%
  ggplot(aes(x = x,
             y = values2, 
             color = new_names))+
  geom_line(aes(linetype = cost_structure), linewidth = 1)+
  facet_grid(~quantile)+
  scale_linetype_manual(values=c("twodash", "solid"))+
  scale_color_manual(values = palette_)+
  theme_bw()+
  guides(
    color = guide_legend(
      title = " ",  # Title for the first column
      ncol = 2              # Number of columns
    ),
    linetype = guide_legend(
      title = ' ',
      ncol = 2
    ))+
  xlab('Population')+
  ylab('Harvest')+
  theme(legend.position = 'bottom',
        strip.text.x  = element_text(family = font_) ,
        axis.title.x  = element_text(family = font_),
        axis.text = element_text(family = font_),
        axis.title.y  = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))
p
if(!file.exists(here('visuals', 'supplementary_visuals', 'equilibria_with_W1_W2.png'))){
  p
  ggsave(here('visuals', 'supplementary_visuals', 'equilibria_with_W1_W1.png'),
        width = 30,
        height = 15, 
        units = 'cm') 
}
```

Clearly, the choice of $W_1$ and $W_2$ is important with respect to the anticipated equilibrium in the *vertical monopoly* case : with a linear-quadratic cost function, we no longer can say the monopoly will achieve a *healthy* steady state population. The results in the **post intervention** world are robust to the cost specification, and guarantee population increases in the *quantity adjustment* scenario, while population may marginally diminish in the *price setting* scenario. 

```{r, Equilibria}
# Rename:
rename_W = function(x){
  if(x==costs[1]){
    return('Low Effort Cost')
  }else if(x==costs[2]){
    return('Mid. Effort Cost')
  }else if(x==costs[3]){
    return('High Effort Cost')
  }
}

rename_scenario = function(x){
  if(x %in% c('ss_monop_lq', 'ss_bertrand_lq', 'ss_cournot_lq')){
    return('Linear-Quadratic cost ')
  }else{
    return('Quadratic cost')
  }
}

rename_scenario2 = function(x){
  if(x %in% c('ss_bertrand', 'ss_bertrand_lq')){
    return('Bertrand')
  }else if(x %in% c('ss_cournot', 'ss_cournot_lq')){
    return('Cournot')
  }else if(x %in% c('ss_monop_lq', 'ss_monop')){
    return('Monopoly')
  }
}
rename_quantiles = function(x){
  return(paste0(x,'%'))
}


##### Final Graphs
final_dat %>%
  subset(AC>0)%>%
  subset(names %in% c('ss_monop_lq', 'ss_monop'))%>%
  mutate(new_AC = factor(sapply(AC, rename_W), 
                         levels = c('Low Effort Cost', 
                                    'Mid. Effort Cost', 
                                    'High Effort Cost')),
         new_names = sapply(names, rename_scenario),
         tamr = paste(new_names, new_AC, sep = ' '),
         new_quantile = sapply(quantile, rename_quantiles))%>%
  subset(new_quantile %in% c('10%','20%', '50%', '80%','90%'))%>%
  ggplot(aes(x = new_names, y = x, color = Stable))+
  scale_color_manual(values = c('darkblue', 'brown'))+
  geom_point(size = 2)+
  #scale_color_continuous('Estimate of unit effort cost', type = 'viridis')+
  facet_grid(new_AC~new_quantile)+
  theme_bw()+
  xlab(' ')+
  ylab(' ')+
  ggtitle("Vertical monopoly steady states with linear and linear quadratic costs")+
  theme(axis.text.x = element_text(angle = 60, 
                                   hjust = 1,
                                   family = font_), 
        axis.title.x= element_text(family = font_),
        axis.title.y = element_text(family = font_),
        plot.title = element_text(hjust = 0.5,
                                  family = font_),
        strip.text.x  = element_text(family = font_) ,
        axis.text = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))
```

```{r, Cournot}

final_dat %>%
  subset(AC>0)%>%
  subset(names %in% c('ss_cournot_lq', 'ss_cournot'))%>%
  mutate(new_AC = factor(sapply(AC, rename_W), 
                         levels = c('Low Effort Cost', 
                                    'Mid. Effort Cost', 
                                    'High Effort Cost')),
         new_names = sapply(names, rename_scenario),
         tamr = paste(new_names, new_AC, sep = ' '),
         new_quantile = sapply(quantile, rename_quantiles))%>%
  subset(new_quantile %in% c('10%','20%', '50%', '80%','90%'))%>%
  ggplot(aes(x = new_names, y = x, color = Stable))+
  scale_color_manual(values = c('darkblue', 'brown'))+
  geom_point(size = 2)+
  #scale_color_continuous('Estimate of unit effort cost', type = 'viridis')+
  facet_grid(new_AC~new_quantile)+
  theme_bw()+
  xlab(' ')+
  ylab(' ')+
  ggtitle("Quantity adjustment steady states with linear and linear quadratic costs")+
  theme(axis.text.x = element_text(angle = 60, 
                                   hjust = 1,
                                   family = font_), 
        axis.title.x= element_text(family = font_),
        axis.title.y = element_text(family = font_),
        plot.title = element_text(hjust = 0.5,
                                  family = font_),
        strip.text.x  = element_text(family = font_) ,
        axis.text = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))
```

```{r, Bertrand}
final_dat %>%
  subset(AC>0)%>%
  subset(names %in% c('ss_bertrand_lq', 'ss_bertrand'))%>%
  mutate(new_AC = factor(sapply(AC, rename_W), 
                         levels = c('Low Effort Cost', 
                                    'Mid. Effort Cost', 
                                    'High Effort Cost')),
         new_names = sapply(names, rename_scenario),
         tamr = paste(new_names, new_AC, sep = ' '),
         new_quantile = sapply(quantile, rename_quantiles))%>%
  subset(new_quantile %in% c('10%','20%', '50%', '80%','90%'))%>%
  ggplot(aes(x = new_names, y = x, color = Stable))+
  scale_color_manual(values = c('darkblue', 'brown'))+
  geom_point(size = 2)+
  #scale_color_continuous('Estimate of unit effort cost', type = 'viridis')+
  facet_grid(new_AC~new_quantile)+
  theme_bw()+
  xlab(' ')+
  ylab(' ')+
  ggtitle("Price setting steady states with linear and linear quadratic costs")+
  theme(axis.text.x = element_text(angle = 60, 
                                   hjust = 1,
                                   family = font_), 
        axis.title.x= element_text(family = font_),
        axis.title.y = element_text(family = font_),
        plot.title = element_text(hjust = 0.5,
                                  family = font_),
        strip.text.x  = element_text(family = font_) ,
        axis.text = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))


```

# Run sensitivity analysis for linear quadratic model

In this section : 

* Define the scenarios to run sensitivity analysis on: use the sensitivity table used previously and interpolate with `W_lq`

* Run all the analysis

* Identify the parameter spaces for which the targets of (i) improving stock and (ii) maintaining profitability are **met** or not

## I. Define parameter spaces

```{r, sensitivity analysis}
rm(dat_,
   store,
   result1, 
   W_lq, 
   w_pal_val_conf, 
   w_par, 
   w_par_ops, 
   w_par_val)

if(!file.exists(here('data', 'inputs', 'params_sensitivity_lq.csv'))){
  print('File : params_sensitivity_lq.csv is not in data/inputs/')
  # Load original parameters for sensitivity analysis. 
  params_sensitivity = read.csv(here('data', 'inputs', 'params_sensitivity.csv'))
  # Set up names for new sensitivity analysis scenarios
  new_params_sensitivity = data.frame(matrix(nrow = 0, ncol = 15 ))
  colnames(new_params_sensitivity) = c(colnames(params_sensitivity), 'W1', 'W2', 'quantile')
  # Set each row of data as a scenario
  for(row in 1:nrow(params_sensitivity)){
    W = params_sensitivity[row, 'W']
    # Set cost that would work in quadratic case
    cost = 2*max_E*W
    # Generate costs that solve the linear quadratic cost
    W1 = quantile(seq(0, cost), probs = c(0, .2, .5, .7, 1))
    W2 = rev(quantile((cost - W1)/(2*max_E), probs = c(0, .2, .5, .7, 1)))
    # Set storage 
    to_append = data.frame(W, W1, W2)
    to_append = to_append %>% 
      mutate(quantile = rownames(to_append))%>%
      select(-W)
    rownames(to_append) = NULL
    
    # Extend existing row scenario with new data on costs
    a = cbind(params_sensitivity[rep(row, nrow(to_append)),], to_append)
    # Store
    new_params_sensitivity = rbind(new_params_sensitivity, a)
  }
  # Save data
  new_params_sensitivity = new_params_sensitivity %>%
    mutate(identifier = seq(1:nrow(new_params_sensitivity)))
  write.csv(new_params_sensitivity, here('data', 'inputs', 'params_sensitivity_lq.csv'), row.names = F)
}else{
  new_params_sensitivity = read.csv(here('data', 'inputs', 'params_sensitivity_lq.csv'))
}

print(paste0("There are ", nrow(new_params_sensitivity), " combinations" ))
```

## II. Run sensitivity analysis

```{r, sensitivity}
model_run = function(param,
                     tol = 1){
  # Variable assignment
  to_assign = names(param)
  if('X' %in% to_assign){
    to_assign = to_assign[!(to_assign %in% c('X','spec', 'transformation', 'quantile'))]
    }
  for(variable in to_assign){
        assign(variable, 
               as.numeric(unlist(param[variable])))
    }
  # Compute secondary parameters
  alpha_w = alpha
  alpha_f = alpha
  beta_w = beta
  beta_f = beta
  # Demand functions parameters
  e   = gamma/(beta_w*beta_f - (gamma^2))
  a_f = (alpha_f*beta_w - alpha_w*gamma)/(beta_w*beta_f - (gamma^2))
  a_w = (alpha_w*beta_f - alpha_f*gamma)/(beta_w*beta_f - (gamma^2))
  b_f = beta_f/(beta_w*beta_f - (gamma^2))
  b_w = beta_w/(beta_w*beta_f - (gamma^2))
  
  W_mid = W
  # Define functions : 
  growth = function(x, 
                    k.=k, 
                    r.=r){
  y = r.*x*(1-x/k.)
  return(y)
}

# I. Price taker
  pt_harvest = function(x, 
                        alpha. = alpha, 
                        beta. = beta, 
                        W. = W_mid, 
                        c. = c, 
                        sigma. = sigma){
  y = ((alpha.-c.) * x^2 * sigma.^2)/(4*W. + beta. * sigma.^2 * x^2)
  return(y)
  }

# II. Monopoly
  monop_harvest = function(x, 
                           alpha. = alpha, 
                           c. = c, 
                           sigma. = sigma, 
                           beta. = beta, 
                           W. = W_mid){
  y = ((alpha. - c.)*sigma.^2 * x^2) / (2*beta.* sigma.^2 * x^2 + 2*W.)
  return(y)
  }

  monop_harvest_lq = function(x,
                              alpha. = alpha, 
                              c. = c, 
                              sigma. = sigma, 
                              beta. = beta,
                              W1. = W1,
                              W2. = W2){
  y = (sigma.^2 * x^2 * (alpha. - c.) - W1.*sigma.*x)/(2*(beta.*sigma.^2 * x^2 + W2.))
  return(y)
  }


# III. Cournot

  cournot_harvest = function(x, 
                             alpha_f. = alpha_f, 
                             alpha_w. = alpha_w, 
                             beta_f. = beta_f, 
                             beta_w. = beta_w, 
                             gamma. = gamma, 
                             sigma. = sigma, 
                             c. = c, 
                             v. = v, 
                             W. = W_mid){
  y = ((sigma.^2)*(x^2)*(2*beta_f.*(alpha_w. - c.) - gamma.*(alpha_f. - v.)))/(4*beta_f.*W. + (sigma.^2)*(x^2)*(4*beta_f.*beta_w. - (gamma.^2)))
  return(y)
  }

  cournot_harvest_lq = function(x, 
                                alpha_f. = alpha_f, 
                                alpha_w. = alpha_w, 
                                beta_f. = beta_f, 
                                beta_w. = beta_w, 
                                gamma. = gamma, 
                                sigma. = sigma, 
                                c. = c, 
                                v. = v, 
                                W1. = W1, 
                                W2. = W2){
  y = ((2*beta_f. * (alpha_w. - c.) - gamma. * (alpha_w. -v.))*sigma.^2 * x^2 - 2*beta_f.*W1.*sigma.*x)/(4*beta_f.*W2. + (4*beta_f.*beta_w. - gamma.^2)*sigma.^2 * x^2)
  return(y)
  }

  price_poachers_cournot = function(x,
                                    alpha_f. = alpha_f, 
                                    alpha_w. = alpha_w, 
                                    beta_f. = beta_f, 
                                    beta_w. = beta_w, 
                                    gamma. = gamma, 
                                    sigma. = sigma, 
                                    c. = c, 
                                    v. = v, 
                                    W. = W_mid){
  y = (2*W.*(2*beta_f.*(alpha_w. - c.) - gamma.*(alpha_f. - v.)))/((sigma.^2)*(x^2)*(4*beta_f.*beta_w. - gamma.^2) + 4*beta_f.*W.)
  return(y)
  }

  cournot_farmed = function(s, 
                            alpha_f. = alpha_f, 
                            alpha_w. = alpha_w, 
                            beta_f. = beta_f, 
                            beta_w. = beta_w, 
                            gamma. = gamma, 
                            sigma. = sigma, 
                            c. = c, 
                            v. = v){
  y = (2 * beta_w. * (alpha_f. - v.) - gamma.* (alpha_w. - (s + c.)) )/(4*beta_w.*beta_f. - gamma.^2)
  return(y)
  }

# IV. Bertrand

  price_poachers_bertrand = function(x, 
                                     a_f. = a_f, 
                                     a_w. = a_w, 
                                     b_f. = b_f, 
                                     b_w. = b_w, 
                                     e.  = e, 
                                     c. = c, 
                                     v. = v, 
                                     sigma. = sigma, 
                                     W. = W_mid){
  y = (2*W.*b_w.*( b_f.*(2*a_w. + e.*v.) + c.*((e.^2) - 2*b_f.*b_w.) + e.*a_f.))/((sigma.^2)*(x^2)*(4*b_f.*b_w. - (e.^2)) + 2*W.*b_w.*(2*b_w.*b_f. - (e.^2)))
  return(y)
  }

  bertrand_harvest = function(x,
                              sigma. = sigma, 
                              a_f. = a_f, 
                              a_w. = a_w, 
                              b_f. = b_f, 
                              b_w. = b_w, 
                              e. = e, 
                              v. = v, 
                              c. = c, 
                              W. = W_mid){
  y = ((sigma.^2)*(x^2)*b_w.*(b_f.*(2*a_w.+e.*v.) + c.*((e.^2)- 2*b_f.*b_w.) + e.*a_f.))/((sigma.^2)*(x^2)*(4*b_w.*b_f. - (e.^2)) + 2*W.*b_w.*(2*b_f.*b_w. - (e.^2)))
  return(y)
  }

  bertrand_harvest_lq = function(x,
                                 sigma. = sigma, 
                                 a_f. = a_f, 
                                 a_w. = a_w, 
                                 b_f. = b_f, 
                                 b_w. = b_w, 
                                 e. = e, 
                                 v. = v, 
                                 c. = c, 
                                 W1. = W1, 
                                 W2. = W2){
  y1 = b_w.*(sigma.^2 * x^2 *((2*a_w. +e.*v.)*b_f. + e.*a_f.) + (c. + W1. * sigma. * b_w. * x)*(e.^2 - 2*b_w. *b_f.))
  y2 = 2*W2.*b_w.*(2*b_f.* b_w. - e.^2) + (4*b_f.*b_w. - e.^2)*sigma.^2*x^2
  z = y1*y2
  return(z)
  }

  price_poacher_bertrand_lq = function(x,
                                       sigma. = sigma, 
                                       a_f. = a_f, 
                                       a_w. = a_w, 
                                       b_f. = b_f, 
                                       b_w. = b_w, 
                                       e. = e, 
                                       v. = v, 
                                       c. = c, 
                                       W1. = W1, 
                                       W2. = W2){
  y = 2*b_w.*W2.*((2*a_w. + e.*v.)*b_f. + e.*a_f. + c.*(e.^2 - b_f.*b_w.)) + W1.*sigma.*x*(4*b_f.*b_w. - e.^2)
  z = sigma.^2 * x^2 * (4*b_w.*b_f. - e.^2) + 4*b_w.*W2.*(2*b_f.*b_w - e.^2)
  result = y/z
  return(result)
 }

  composite_bertrand_lq = function(x,
                                   sigma. = sigma, 
                                   a_f. = a_f, 
                                   a_w. = a_w, 
                                   b_f. = b_f, 
                                   b_w. = b_w, 
                                   e. = e, 
                                   v. = v, 
                                   c. = c, 
                                   W1. = W1, 
                                   W2. = W2){
  y = b_w. * ((2*a_w. +e.*v.)*b_f. + e.*a_f. + (price_poacher_bertrand_lq(x)+c.)*(e.^2 - 2*b_w.*b_f))/(4*b_f.*b_w. - e.^2)
  return(y)
  }

  bertrand_farmed = function(s, 
                             a_f. = a_f, 
                             a_w. = a_w, 
                             b_f. = b_f, 
                             b_w. = b_w, 
                             e. = e, 
                             c. = c, 
                             v. = v){
  y = b_f. *(2*b_w.*a_f. + v.*(e.^2 - 2*b_w.*b_f.) + e.*(a_w. + (s+c.)*b_w.))/(4*b_f.*b_w. - e.^2)
  return(y)
  }
  
  # Run model 
  kolaf = data.frame(x = seq(1,k,.5 ))%>%
    mutate(growth= growth(x),
           monop_harvest = monop_harvest(x),
           monop_harvest_lq = monop_harvest_lq(x),
           cournot_harvest = cournot_harvest(x),
           cournot_harvest_lq = cournot_harvest_lq(x),
           bertrand_harvest = bertrand_harvest(x),
           bertrand_harvest_lq = composite_bertrand_lq(x),
           ss_monop = monop_harvest - growth, 
           ss_monop_lq = monop_harvest_lq - growth, 
           ss_cournot = cournot_harvest - growth, 
           ss_cournot_lq = cournot_harvest_lq - growth,
           ss_bertrand = bertrand_harvest - growth, 
           ss_bertrand_lq = bertrand_harvest_lq - growth,
           price_poachers_lq = price_poacher_bertrand_lq(x),
           price_poachers_bertrand = price_poachers_bertrand(x)) 
  #Identify steady states  
  errr= kolaf %>%
    pivot_longer(-x, 
                 names_to = 'names', 
                 values_to = 'values')%>%
    subset(names %in% c('ss_monop',
                        'ss_monop_lq',
                        'ss_cournot',
                        'ss_cournot_lq',
                        'ss_bertrand',
                        'ss_bertrand_lq'))%>%
    subset(values > -tol)%>%
    subset(values < tol)
 
  keep_row = data.frame(matrix(nrow = 0, ncol = 4))
  colnames(keep_row)= c('x', 'names', "values", 'lag_sign')

  for(name in unique(errr$names)){
    study = errr %>%
      subset(names == name)%>%
      mutate(lag_sign = c(0, diff(sign(values))), # Mutate to get sign change and value of steady state change
             lag_val = c(0, diff(x)))
    # Define cut vector to scan through each zone : cuts are defined as jumps in x value 
      cuts_ = which(study$lag_val>5 | study$lag_val < -5) - 1
      cuts_ = c(0,cuts_, nrow(study))
    # Use cuts vector to scan through
      keep = data.frame(matrix(nrow = 0, ncol = 4))
      colnames(keep) = c('x', 'names', "values", 'lag_sign')

    for(cut in 1:(length(cuts_)-1)){
      lb_ = cuts_[cut]+1
      ub_ = cuts_[cut+1]
    
      to_check = study[lb_: ub_,]%>%
        subset(lag_sign !=0)%>%
        subset(lag_val>0)%>% # Keep only when the lag value is positive : otherwise, it means a change in sequence or type of equilibrium
        select(-c(lag_val))
      
      keep = rbind(keep, to_check)
    }
  keep_row = rbind(keep_row, keep)
  }
  # Store
  keep_row = keep_row %>%
    mutate(row_ =unlist(param['identifier']))
 return(keep_row)
}

if(!file.exists(here('data', 'outputs', 'sensitivity_analysis_lq', 'steady_states.csv'))){
  print("File steady_states.csv is not in 'data/outputs/sensitivity_analysis_lq' ")
  # Set up cores
  numcores = detectCores() - 4
    # Make clusters
  cl = makeCluster(numcores)
    # Load tidyverse : otherwise, pipe operator is not recognized
  clusterEvalQ(cl,  library(tidyverse))
    # Start timer
  start = Sys.time()
    # Apply function accross nodes with a slice of the data of lenght width
  storage = parApply(cl, 
                    new_params_sensitivity,
                    1,
                    model_run)
  print(paste0('Process took : ', Sys.time() - start, ' minutes with ', numcores, ' processors'))

  storage = bind_rows(storage)
  write.csv(storage, here('data', 'outputs','sensitivity_analysis_lq', 'steady_states.csv'), row.names = F)

}else{
  storage = read.csv(here('data', 'outputs','sensitivity_analysis_lq', 'steady_states.csv'))
  print('Loading results from data/outputs/sensitivity_analysis_lq/steady_states.csv')
}
```

## III. Exploit data

* Define a baseline scenario : in this case, take $W$ as our main specification, and the midpoint for $W_1$ and $W_2$

* Compute the difference in steady state

* Somehow illustrate it

```{r, sensitivity results}
new_params_sensitivity = new_params_sensitivity%>%
  rename(row_ = identifier)
storage = storage %>%
  mutate(row_ = as.numeric(row_))

exploit_ = merge(storage, new_params_sensitivity, by = 'row_')%>%
  distinct()%>%
  mutate(row_ = as.numeric(row_))

if('X.1' %in% colnames(exploit_)){
  exploit_ = exploit_ %>%
    select(- X.1)
}


normalizer = exploit_ %>%
  subset(spec == 'baseline')%>%
  subset(quantile == '50%')%>%
  subset(names == 'ss_monop')%>%
  select(x)%>%
  pull()

exploit_ = exploit_%>%
  mutate(normalized_ss = (x-normalizer)/normalizer*100)
```

How equilibria evolve with varying farming costs ($v$) and with varying cost splits in the LQ case : 

```{r, illustration}
v_color = function(x){
  if(x %in% c(paste(unique(exploit_$v), -2))){
    return('Unstable')
  }else{
    return(strsplit(x, ' ')[[1]][1])
  }
}

palette = c(brewer.pal(8, 'Blues'), paste0('grey',seq(50,90, by = 5)))

check = exploit_ %>%
  #subset(quantile %in% c('50%'))%>%
  subset(spec == 'v')%>%
  subset(names != 'ss_monop')%>%
  mutate(quantile = as.factor(quantile),
         names = as.factor(names), 
         v_stab = paste(round(v,1), 
                        lag_sign),
         labels_W = paste('W1: ', round(W1,2), ' and W2: ', round(W2,2)))
to_lev = c(unique(round(check$v,1)),
           paste(unique(round(check$v,1)), -2))

check$v_stab = factor(check$v_stab)
levels(check$v_stab) = to_lev

check%>%
  ggplot(aes(x = names, 
           y= normalized_ss, 
           color = as.factor(v),
           shape = as.factor(lag_sign)))+
  geom_point(position = position_dodge(.8), size = 3)+
  scale_color_manual(values = palette)+
  scale_shape_manual(values= c(4, 19))+
  facet_grid(~labels_W)+
  scale_x_discrete()+
  theme_minimal()+
  theme(axis.text.x = element_text(family = font_, 
                                   angle = 45, 
                                   hjust = .75))

# Here : 
# - Make v_stab2 a factor and make the values fall in relevant order
# - Color scale with length()/2 +1 (with last one in gray)
# - Change the labels in the legend
# - Use guide legend (override.aes) with alpha = 0 for length/2-1 last value
```


```{r, graph exploration}
unique(exploit_$spec)
store_cv = data.frame(matrix(nrow = 0, ncol = length(exploit_)))
colnames(store_cv) = colnames(exploit_)
names__ = unique(exploit_$names)
for(x in c('0%','20%','50%', '70%', '100%')){
  zebi = x
  
  z_min = exploit_ %>%
    subset(spec == 'c and v') %>%
    subset(quantile == zebi) %>%
    subset(lag_sign > 0)%>%
    group_by(row_, names)%>%
    summarize(min_outcome = min(normalized_ss))
  
  z = exploit_ %>%
  subset(spec == 'c and v') %>%
  subset(quantile == zebi) %>%
  subset(lag_sign > 0)%>%
  inner_join(z_min, by = c('row_', 'names'))%>%
  filter(normalized_ss == min_outcome)
  
  store_cv = rbind(store_cv, z)
}

#store_cv%>%
#  subset(quantile %in% c('0%','50%', '100%'))%>%
#  ggplot(aes(x=c, y = v, fill = normalized_ss))+
#  geom_tile()+
#  facet_grid()+
  #scale_fill_gradient2(low = 'navyblue', 
  #                     high = 'gold', 
  #                     mid = 'white',
  #                     midpoint = 0, 
  #                     limit = c(-99,7))+
#  theme_minimal()+
#  facet_grid(cols = vars(names), rows = vars(quantile))

#store_cv %>%
#  subset(quantile %in% c('0%', '50%', '100%'))%>%
#  ggplot(aes( x = as.factor(c), 
#              y = as.factor(v), 
#              color = normalized_ss))+
#  geom_point()+
#  facet_grid(cols = vars(names), rows = vars(quantile))
```

### IV. Include profitability

In this section : 

* Define profit functions 

* Check the profit at steady state levels

* Compare with baseline scenario

```{r, define profitability}
profit = function(param){
  # Variable assignement
  to_assign = names(param)
  
  
  if('row_' %in% to_assign){
    to_assign = to_assign[!(to_assign %in% c('X','spec', 'transformation', 'quantile', 'normalized_ss'))]
    }
  for(variable in to_assign){
    if(variable == 'names'){
      assign(variable,
             unlist(param[variable]))
    }else{
        assign(variable, 
               as.numeric(unlist(param[variable])))
    }
  }
  
  alpha_w = alpha
  alpha_f = alpha
  beta_w = beta
  beta_f = beta
  # Demand functions parameters
  e   = gamma/(beta_w*beta_f - (gamma^2))
  a_f = (alpha_f*beta_w - alpha_w*gamma)/(beta_w*beta_f - (gamma^2))
  a_w = (alpha_w*beta_f - alpha_f*gamma)/(beta_w*beta_f - (gamma^2))
  b_f = beta_f/(beta_w*beta_f - (gamma^2))
  b_w = beta_w/(beta_w*beta_f - (gamma^2))
  
  W_mid = W
  
  if(names == 'ss_monop'){
    # Redefine harvest
    monop_harvest = function(x, 
                             alpha. = alpha, 
                             c. = c, 
                             sigma. = sigma, 
                             beta. = beta, 
                             W. = W_mid){
    y = ((alpha. - c.)*sigma.^2 * x^2) / (2*beta.* sigma.^2 * x^2 + 2*W.)
    return(y)
    }
    # Define outputs : 
      # Poached harvest
    poached_harvest = monop_harvest(x)
      # Farmed harvest : 
    farmed_harvest = 0
    # Prices paid:
    price_poachers = (alpha_w - c)*W/(beta*sigma^2*x^2+W)
    price_retail = (alpha - beta*poached_harvest)
    # Profits:
      # Profit from poaching
    profit_poaching = (alpha - beta * poached_harvest - c - price_poachers)*poached_harvest
      # Profit from farming
    profit_farming = 0
    profit_fishermen = (price_poachers*sigma*x)^2/(4*W)
    
  }else if(names == 'ss_monop_lq'){
    # Redefine harvest
    monop_harvest_lq = function(x,
                                alpha. = alpha, 
                                c. = c, 
                                sigma. = sigma, 
                                beta. = beta,
                                W1. = W1,
                                W2. = W2){
    y = (sigma.^2 * x^2 * (alpha. - c.) - W1.*sigma.*x)/(2*(beta.*sigma.^2 * x^2 + W2.))
    return(y)
    }
    # Harvest:
    poached_harvest = monop_harvest_lq(x)
    farmed_harvest = 0
    # Price : 
    price_poachers = (W2*(alpha-c)+beta*W1*sigma*x)/(beta*sigma^2*x^2 + W2)
    price_retail = (alpha - beta*poached_harvest)
    # Redefine profit
    profit_poaching = (alpha - beta*poached_harvest - c - price_poachers)*poached_harvest
    profit_fishermen = price_poachers * poached_harvest - W1*((price_poachers * sigma * x -W1)/(2*W2)) - W2*((price_poachers * sigma * x - W1)/(2*W2))^2
    profit_farming = 0
  }else if(names == 'ss_cournot'){
    # Redefine harvests and price paid to poachers
    cournot_harvest = function(x, 
                               alpha_f. = alpha_f, 
                               alpha_w. = alpha_w, 
                               beta_f. = beta_f, 
                               beta_w. = beta_w, 
                               gamma. = gamma, 
                               sigma. = sigma, 
                               c. = c, 
                               v. = v, 
                               W. = W_mid){
        y = ((sigma.^2)*(x^2)*(2*beta_f.*(alpha_w. - c.) - gamma.*(alpha_f. - v.)))/(4*beta_f.*W. + (sigma.^2)*(x^2)*(4*beta_f.*beta_w. - (gamma.^2)))
        return(y)
      }
    
    price_poachers_cournot = function(x,
                                      alpha_f. = alpha_f, 
                                      alpha_w. = alpha_w, 
                                      beta_f. = beta_f, 
                                      beta_w. = beta_w, 
                                      gamma. = gamma, 
                                      sigma. = sigma, 
                                      c. = c, 
                                      v. = v, 
                                      W. = W_mid){
    y = (2*W.*(2*beta_f.*(alpha_w. - c.) - gamma.*(alpha_f. - v.)))/((sigma.^2)*(x^2)*(4*beta_f.*beta_w. - gamma.^2) + 4*beta_f.*W.)
    return(y)
    }

    cournot_farmed = function(s, 
                              alpha_f. = alpha_f, 
                              alpha_w. = alpha_w, 
                              beta_f. = beta_f, 
                              beta_w. = beta_w, 
                              gamma. = gamma, 
                              sigma. = sigma, 
                              c. = c, 
                              v. = v){
    y = (2 * beta_w. * (alpha_f. - v.) - gamma.* (alpha_w. - (s + c.)) )/(4*beta_w.*beta_f. - gamma.^2)
    return(y)
    }
    
    # Results  
    poached_harvest = cournot_harvest(x)
    price_poachers = price_poachers_cournot(x)
    farmed_harvest = cournot_farmed(price_poachers)
    
    price_retail = (alpha_w - beta_w * poached_harvest - gamma * farmed_harvest)
    profit_poaching = (alpha_w - beta_w * poached_harvest - gamma * farmed_harvest - c - price_poachers)*poached_harvest
    profit_farming  = (alpha_f - beta_f * farmed_harvest - gamma * poached_harvest - v) * farmed_harvest
    profit_fishermen = (price_poachers*x*sigma)^2/(4*W)
    
  }else if(names == 'ss_cournot_lq'){
    cournot_harvest_lq = function(x, 
                                  alpha_f. = alpha_f, 
                                  alpha_w. = alpha_w, 
                                  beta_f. = beta_f, 
                                  beta_w. = beta_w, 
                                  gamma. = gamma, 
                                  sigma. = sigma, 
                                  c. = c, 
                                  v. = v, 
                                  W1. = W1, 
                                  W2. = W2){
    y = ((2*beta_f. * (alpha_w. - c.) - gamma. * (alpha_w. -v.))*sigma.^2 * x^2 - 2*beta_f.*W1.*sigma.*x)/(4*beta_f.*W2. + (4*beta_f.*beta_w. - gamma.^2)*sigma.^2 * x^2)
    return(y)
    }
    
    poached_harvest = cournot_harvest_lq(x)
    price_poachers = (2*W2*(2*beta_f*(alpha_w - c) - gamma*(alpha_f - v)) + W1*sigma*x*(4*beta_f*beta_w - gamma^2))/(4*beta_f*W2 + (4*beta_f*beta_w - gamma^2)*sigma^2*x^2)
    farmed_harvest = (2*beta_w*(alpha_f - v) - gamma*(alpha_w - price_poachers - c))/(4*beta_w*beta_f - gamma^2)
    
    price_retail = (alpha_w - beta_w * poached_harvest - gamma * farmed_harvest)
    profit_poaching = (alpha_w - beta_w * poached_harvest - gamma * farmed_harvest - price_poachers - c)*poached_harvest
    profit_farming =  (alpha_f - beta_f * farmed_harvest - gamma * poached_harvest - v)* farmed_harvest
    profit_fishermen = price_poachers * poached_harvest - W1*((price_poachers * sigma * x -W1)/(2*W2)) - W2*((price_poachers * sigma * x - W1)/(2*W2))^2
    
  }else if(names == 'ss_bertrand'){
    
    price_poachers_bertrand = function(x, 
                                       a_f. = a_f, 
                                       a_w. = a_w, 
                                       b_f. = b_f, 
                                       b_w. = b_w, 
                                       e.  = e, 
                                       c. = c, 
                                       v. = v, 
                                       sigma. = sigma, 
                                       W. = W_mid){
    y = (2*W.*b_w.*( b_f.*(2*a_w. + e.*v.) + c.*((e.^2) - 2*b_f.*b_w.) + e.*a_f.))/((sigma.^2)*(x^2)*(4*b_f.*b_w. - (e.^2)) + 2*W.*b_w.*(2*b_w.*b_f. - (e.^2)))
    return(y)
    }

    bertrand_harvest = function(x,
                                sigma. = sigma, 
                                a_f. = a_f, 
                                a_w. = a_w, 
                                b_f. = b_f, 
                                b_w. = b_w, 
                                e. = e, 
                                v. = v, 
                                c. = c, 
                                W. = W_mid){
    y = ((sigma.^2)*(x^2)*b_w.*(b_f.*(2*a_w.+e.*v.) + c.*((e.^2)- 2*b_f.*b_w.) + e.*a_f.))/((sigma.^2)*(x^2)*(4*b_w.*b_f. - (e.^2)) + 2*W.*b_w.*(2*b_f.*b_w. - (e.^2)))
    return(y)
    }
    bertrand_farmed = function(s, 
                               a_f. = a_f, 
                               a_w. = a_w, 
                               b_f. = b_f, 
                               b_w. = b_w, 
                               e. = e, 
                               c. = c, 
                               v. = v){
    y = b_f. *(2*b_w.*a_f. + v.*(e.^2 - 2*b_w.*b_f.) + e.*(a_w. + (s+c.)*b_w.))/(4*b_f.*b_w. - e.^2)
    return(y)
    }
    
    poached_harvest = bertrand_harvest(x)
    price_poachers = price_poachers_bertrand(x)
    farmed_harvest = bertrand_farmed(price_poachers)
    price_retail = (alpha_w - beta_w * poached_harvest - gamma * farmed_harvest)
    profit_fishermen = (price_poachers*x*sigma)^2/(4*W)
    profit_poaching = (alpha_w - beta_w * poached_harvest - gamma * farmed_harvest - c - price_poachers) * poached_harvest
    profit_farming = (alpha_f - beta_f * farmed_harvest - gamma * poached_harvest - v)*farmed_harvest
    
  }else if(names == 'ss_bertrand_lq'){
    price_poacher_bertrand_lq = function(x,
                                         sigma. = sigma, 
                                         a_f. = a_f, 
                                         a_w. = a_w, 
                                         b_f. = b_f, 
                                         b_w. = b_w, 
                                         e. = e, 
                                         v. = v, 
                                         c. = c, 
                                         W1. = W1, 
                                         W2. = W2){
    y = 2*b_w.*W2.*((2*a_w. + e.*v.)*b_f. + e.*a_f. + c.*(e.^2 - b_f.*b_w.)) + W1.*sigma.*x*(4*b_f.*b_w. - e.^2)
    z = sigma.^2 * x^2 * (4*b_w.*b_f. - e.^2) + 4*b_w.*W2.*(2*b_f.*b_w - e.^2)
    result = y/z
    return(result)
    }

    composite_bertrand_lq = function(x,
                                     sigma. = sigma, 
                                     a_f. = a_f, 
                                     a_w. = a_w, 
                                     b_f. = b_f, 
                                     b_w. = b_w, 
                                     e. = e, 
                                     v. = v, 
                                     c. = c, 
                                     W1. = W1, 
                                     W2. = W2){
    y = b_w. * ((2*a_w. +e.*v.)*b_f. + e.*a_f. + (price_poacher_bertrand_lq(x)+c.)*(e.^2 - 2*b_w.*b_f))/(4*b_f.*b_w. - e.^2)
    return(y)
    }
    
    price_poachers = price_poacher_bertrand_lq(x)
    poached_harvest = composite_bertrand_lq(price_poachers)
    farmed_harvest = b_f*(b_w*(2*a_f + e*(price_poachers + c)) + e*a_w + v*(e^2 - 2*b_w*b_f))/(4*b_f*b_w - e^2)
    
    price_retail = (alpha_w - beta_w * poached_harvest - gamma * farmed_harvest)
    profit_poaching = (alpha_w - beta_w * poached_harvest - gamma*farmed_harvest - price_poachers - c)*poached_harvest
    profit_farming = (alpha_f - beta_f * farmed_harvest - gamma * poached_harvest -v)*farmed_harvest
    profit_fishermen = price_poachers * poached_harvest - W1*((price_poachers * sigma * x -W1)/(2*W2)) - W2*((price_poachers * sigma * x - W1)/(2*W2))^2
  }
  
  result = data.frame(row_, names, poached_harvest, farmed_harvest, price_retail, price_poachers, profit_poaching, profit_farming, profit_fishermen, lag_sign)
  rownames(result) = NULL
  #result = t(as.data.frame(result))
  colnames(result) = c('row_', 'names','poached_harvest', 'farmed_harvest','price_retail', 'price_poachers', 'profit_poaching', 'profit_farming', 'profit_fishermen','stability')
  return(result)
}
 
if(!file.exists(here('data', 'outputs', 'sensitivity_analysis_lq', 'profitability.csv'))){
  print("Profitability results are not in data/outputs/sensitivity_analysis_lq")
  # Set up cores
  numcores = detectCores() - 4
    # Make clusters
  cl = makeCluster(numcores)
    # Load tidyverse : otherwise, pipe operator is not recognized
  clusterEvalQ(cl,  library(tidyverse))
    # Start timer
  start = Sys.time()
    # Apply function accross nodes with a slice of the data of lenght width
  storage = parApply(cl, 
                    exploit_,
                    1,
                    profit)
  print(paste0('Process took : ', Sys.time() - start, ' minutes with ', numcores, ' processors'))

  storage = bind_rows(storage)
  write.csv(storage, here('data', 'outputs','sensitivity_analysis_lq', 'profitability.csv'), row.names = F)

}else{
  storage = read.csv(here('data', 'outputs','sensitivity_analysis_lq', 'profitability.csv'))
  print('Loading profit data from data/outputs/sensitivity_analysis_lq/profitability.csv')
}

```

With profitability done, in the following I :

1. Compute the aggregate profit : **DONE**

2. Compute the cost of policy : based on our baseline estimates, I use the difference with values in the sensitivity analysis, where this is to be taken as a **scenario analysis** instead. I get the per unit cost of policies (subsidies and transaction costs for the traders) : **DONE**

3. Compute the variation for each profit and policy costs, along each scenario : **DONE**

```{r, profitability computation}

if(!file.exists(here('data', 'outputs', 'sensitivity_analysis_lq', 'bioeconomic_performance.csv'))){
  print("bioeconomic_performance.csv is not stored in 'data/outputs/sensitivity_analysis_lq/")
  storage_total = cbind(storage,
                      exploit_ %>%
                        select(-c('row_',
                                  'names',
                                  'lag_sign',
                                  'X')))%>%
  mutate(ag_profit = profit_poaching + profit_farming + profit_fishermen)

# Normalize
  baseline_profit_monop = storage %>%
    subset(names == 'ss_monop')%>%
    subset(row_ == 1)%>%
    select(profit_poaching)%>%
    pull()

  baseline_profit_fishermen = storage %>%
    subset(names == 'ss_monop')%>%
    subset(row_ == 1)%>%
    select(profit_fishermen)%>%
    pull()

  baseline_profit_farming = storage %>%
    subset(names == 'ss_monop')%>%
    subset(row_ == 1)%>%
    select(profit_farming)%>%
    pull()

  baseline_ag_profit = storage_total %>%
    subset(row_ == 1)%>%
    subset(names == 'ss_monop')%>%
    select(ag_profit)%>%
    pull()

# Issue with Pi_farming = 0 in baseline scenario
#storage_stable = storage_stable%>%
#  mutate(ag_profit_rate = (ag_profit - baseline_ag_profit)/ baseline_ag_profit,
#         profit_poaching_rate = (profit_poaching - baseline_profit_monop)/baseline_profit_monop,
#         profit_fishermen_rate = (profit_fishermen) )

# Go with absolute variation : 
  storage_total = storage_total %>%
    mutate(ag_profit_diff = ag_profit - baseline_ag_profit, 
           profit_farming_diff = profit_farming - baseline_profit_farming, 
           profit_poaching_diff = profit_poaching - baseline_profit_monop,
           profit_fishermen_diff = profit_fishermen - baseline_profit_fishermen)

# Extract baseline scenario
  v_baseline = storage_total %>%
    subset(spec == 'baseline')%>%
    select(v)%>%
    pull()%>%
    unique()

  c_baseline = storage_total%>%
    subset(spec== 'baseline') %>%
    select(c)%>%
    pull()%>%
    unique()

  policy_cost = function(row,
                         v_baseline. = v_baseline,
                         c_baseline. = c_baseline){
    if(row['spec'] == 'c'){
      policy_cost = (row['c'] - c_baseline.)*row['poached_harvest']
    }else if(row['spec'] == 'v'){
      policy_cost = (v_baseline. - row['v'])*row['farmed_harvest']
    }else if(row['spec'] == 'c and v'){
      policy_cost = (v_baseline. - row['v'])*row['farmed_harvest'] + (row['c'] - c_baseline.)*row['poached_harvest']
    }else{
      policy_cost = 0
    }
    return(policy_cost)
  }


  to_treat = which(storage_total['spec'] == 'c')
  to_treat2 = which(storage_total['spec'] == 'v')
  to_treat3 = which(storage_total['spec'] == 'c and v')
  to_treat = unique(c(to_treat, to_treat2, to_treat3))


  storage_total['policy_cost'] = 0


  for(x in 1:length(to_treat)){
    storage_total[x, 'policy_cost'] = policy_cost(storage_total[x,])
    }

  rm(to_treat)

  storage_total['ag_net_benefit'] = storage_total['ag_profit'] - storage_total['policy_cost']

  baseline_net_benefit = storage_total %>%
    subset(row_ == 1)%>%
    subset(names == 'ss_monop')%>%
    select(ag_net_benefit)%>%
    pull()

  storage_total['variation_ag_net_benefit'] = (storage_total['ag_net_benefit'] - baseline_net_benefit)/baseline_net_benefit*100
  
  baseline_poaching = storage_total %>%
    subset(row_ == 1)%>%
    subset(names == 'ss_monop')%>%
    select(poached_harvest)%>%
    pull()
  
  storage_total['variation_poaching'] = (storage_total['poached_harvest'] - baseline_poaching)/baseline_poaching*100

  storage_stable = storage_total %>%
    subset(stability>0)
  write.csv(storage_stable, here('data','outputs', 'sensitivity_analysis_lq', 'bioeconomic_performance.csv'), row.names = F)

}else{
  storage_stable = read.csv(here('data','outputs', 'sensitivity_analysis_lq', 'bioeconomic_performance.csv'))
  print('Loading bioeconomic performance data')
 
}

```

The overall outcome for the model  : 
```{r, dev}
# Subset data to display : here spec is baseline
a = storage_stable %>% 
    subset(spec=='baseline')%>%
    select(-c('stability', 'values','gamma', 'W', 'r', 
            'k','values', 'beta', 'alpha','sigma', 'c', 'v', # can keep transformation or other variables if other dimensions need to be checker for sensitivity
            'policy_cost', 'transformation', 'row_'))


renamer= function(x){
  if(x %in% c('ss_monop', 'ss_monop_lq')){
    rep = 'Vertical Monopoly'
  }else if(x %in% c('ss_cournot', 'ss_cournot_lq')){
    rep = 'Quantity adjustment'
  }else if(x %in% c('ss_bertrand', 'ss_bertrand_lq')){
    rep  = 'Price setting'
  }else if(x %in% c('growth')){
    rep = 'Growth'
  }
  if(length(strsplit(x,'_')[[1]])>2){
    rep = paste0(as.character(rep), ' - LQ cost')
  }
  return(rep)
}

a['names']= sapply(a$names, renamer)

a = a%>%
  subset(quantile == '50%')%>% # Can check other quantiles
  select(-c('spec','W1','W2', 'quantile', 'ag_net_benefit'))%>%
  mutate(price_buche_final = price_retail / 1000 * avg_toto_weight,
         price_buche_fisher = price_poachers / 1000 * avg_toto_weight)%>%
  relocate(x, .after = farmed_harvest)%>%
  relocate(normalized_ss, .after = profit_fishermen_diff)%>%
  relocate(price_retail, .before = price_poachers)%>%
  relocate(price_buche_final, .after = price_retail)%>%
  relocate(price_buche_fisher, .after = price_poachers)%>%
  relocate(variation_poaching, .after = normalized_ss)%>%
  mutate(normalized_ss = paste0(round(normalized_ss, 2), '%'), 
         variation_ag_net_benefit = paste0(round(variation_ag_net_benefit,2), '%'), 
         variation_poaching = paste0(round(variation_poaching,2), '%'))%>%
  mutate(profit_farming = round(profit_farming/1000000,2),
         profit_fishermen = round(profit_fishermen/1000000,2),
         profit_poaching = round(profit_poaching/1000000,2),
         ag_profit = round(ag_profit/1000000,2),
         profit_farming_diff = round(profit_farming_diff/1000000,2),
         ag_profit_diff = round(ag_profit_diff/1000000,2),
         profit_fishermen_diff = round(profit_fishermen_diff/1000000,2),
         profit_poaching_diff = round(profit_poaching_diff/1000000,2)
         )%>%
  rename('Scenario' = names, 
         'Steady state population (in mt)' = x,
         'Poached harvest (in mt)' = poached_harvest,
         'Farmed harvest (in mt)' = farmed_harvest,
         'Variation in ss. pop.' = normalized_ss,
         'Price  paid to poacher (in USD/ton of buche)' = price_poachers,
         'Retail price (in USD/ton of buche)' = price_retail,
         'Illegal profit (in million USD)'= profit_poaching,
         'Retail price of 500g buche (in USD)' = price_buche_final,
         'Poacher price of 500g buche (in USD)' = price_buche_fisher,
         'Farming profit (in million USD)' = profit_farming, 
         'Fishing profit (in million USD)' = profit_fishermen,
         "Aggregate profit (in million USD)" = ag_profit,
         'Farming profit change (in million USD)' = profit_farming_diff,
         'Aggregate profit change (in million USD)' = ag_profit_diff, 
         'Fishing profit change (in million USD)' = profit_fishermen_diff,
         'Illegal profit change (in million USD)' = profit_poaching_diff,
         'Aggregate profit change (%)' = variation_ag_net_benefit, 
         'Poaching change (%)' = variation_poaching)

a%>%
  tt(caption = 'Bioeconomic performance - with median LQ cost specification')%>%
  style_tt(j = 1, background = '#eae4e4')%>%
  style_tt(j = 2:4, background = '#cfe2f3')%>%
  style_tt(j = 5:10, background = '#d5f8c8' )%>%
  style_tt(j = 15:17, background = '#f4cccc')%>%
  style_tt(i = 0,  background = '#eae4e4')%>%
  style_tt(j = 1, bold = T)



a %>%
  subset(Scenario %in% c('Vertical Monopoly', 
                         'Quantity adjustment', 
                         'Price setting'))%>%
  tt(caption = 'Bioeconomic performance - with median LQ cost specification')%>%
  style_tt(j = 1, background = '#eae4e4')%>%
  style_tt(j = 2:4, background = '#cfe2f3')%>%
  style_tt(j = 5:8, background = '#d5f8c8' )%>%
  style_tt(j = 9:12, background = '#98f7b5' )%>%
  style_tt(j = 17:19, background = '#f4cccc')%>%
  style_tt(i = 0,  background = '#eae4e4')%>%
  style_tt(j = 1, bold = T)
```

# To do

* Re-run sensitivity analysis and make sure the saving of the data is right : **DONE**

* Finalize the `profit(...)` function and architecture: take the steady-state value only : **DONE**

* Think of ways to visualize both outputs e.g. the population stock and the profitability. 

* Depending on how we feel about the demand assumptions we can maybe include an estimation of the consumer surplus (easy with linear demand scheme), but that may trigger economists.

* Color coding table for various structures

* Convert dollar units to millions of dollars

* Write supplementary materials

