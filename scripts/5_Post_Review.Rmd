---
title: "5_Post Review"
author: "Simon"
date: "2024-01-09"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
options(scipen=999)

rm(list = ls())

library(tidyverse)
library("ggsci")
library(here)
library(knitr)
library(stargazer)

if(!('Fishlife' %in% installed.packages())){
  devtools::install_github("james-thorson/FishLife")
}
library(FishLife)
library(kableExtra)

Latex =T
font_ = 'Helvetica'
color_growth = 'black'
color_vertical_monopoly = 'firebrick'
color_bertrand = '#1f78b4'
color_cournot = 'forestgreen'
palette_ = c(color_growth, color_vertical_monopoly, color_bertrand, color_cournot)
```

# Model with linear quadratic costs

## I. Recover W
### A. Load data
Use the same data as in `1_Parameters.rmd`.
```{r, Load data}
dat_p = read.csv(here("data","inputs","dat_p.csv")) #Price-quantity data (OG Paper)
dat_p = dat_p %>%
  mutate(price_buche = g*p,
         price_kg = p*1000, 
         price_buche_kg = price_buche*1000)


dat_b = read.csv(here('data', 'inputs', "totoaba_biomass_catch_20230516.csv")) %>% 
  rename(y = X) %>% 
  rename(b = Biomass..Tonnes.) %>% 
  rename(c = Catch..Tonnes.)

w_par = read.csv(here("data", 'inputs', "w_par.csv"))
v_par = read.csv(here("data", 'inputs', "v_par.csv")) 

sources = read.csv(here("data", 'inputs', "sources.csv"))

```


### B. Calculate W
Calculate costs of poaching using the same method as in `1_Parameters.rmd`. 
```{r calculating cost of poaching}

# W parameter, proportional increase in cost per unit (trip)

#Step one, get all annual operating costs
# Goal is to calculate cost per vessel trip (we have total fleet days per year which is number of vessels * fishing days per month)
# First calculate total annual costs for the entire fleet

w_par_ops <- w_par %>% 
  mutate(cost_crew_earnings = (totoaba_year * price_fishers_per_totoaba * monthly_earnings_paid)) %>% 
  mutate(cost_food_fuel = (foodfuel_day * total_fleet_days_year)) %>% 
  mutate(cost_gear = total_fleet_days_year*(gear_loss_day*gear_replacement)) %>% 
  mutate(revenue_per_month = (totoaba_year*(price_fishers_per_totoaba)) - (cost_crew_earnings-cost_food_fuel-cost_gear))

# Next, divide by total fishing days per year

w_par_val <- w_par_ops %>% 
  select(vessels, totoaba_day, total_fleet_days_year,cost_crew_earnings,cost_food_fuel,cost_gear,bribes_year,revenue_per_month) %>% 
  mutate(cost_per_trip = (cost_crew_earnings + cost_food_fuel + cost_gear + bribes_year)/total_fleet_days_year) 

#Adding in gear and vessel confiscation (calculated as a shared cost applied to the entire fleet)

w_pal_val_conf <- w_par_val %>%
  add_column(net_confs_cost_fleetday=664000/1920) %>% #Total cost as a proportion of reported confiscations averaged over the year (1,920 fishing trips total). 5,720 nets in the water each year (each vessel sets 2-3 nets), and 0.07 of those nets are confiscated (we know that there are 415 gear confiscation events each year). So if we assume that each net costs $1,600, then our total cost to the fleet is $664,000.
  add_column(vessel_confs_cost_fleetday=1230000/1920) %>% #Total cost as a proportion of reported vessel seizures averaged over the year (1,920 fishing trips total). There are 150 boats in total each year, and 0.546 are confiscated (there are 82 confiscations a year). So we assume each boat is worth $15,000, and therefore the total cost to the fleet is $1,230,000.
  add_column(fines_cost_fleetday=81675/1920) %>% #Total cost as a proportion of reported vessel seizures averaged over the year (1,920 fishing trips total). There are 11 arrests/convictions where people are fined $7,425/event, which would add an additional cost of $42.54.
  mutate(cost_per_trip = (cost_crew_earnings + cost_food_fuel + cost_gear + bribes_year)/total_fleet_days_year) %>% 
  mutate(cost_per_trip_wconf = cost_per_trip + net_confs_cost_fleetday + vessel_confs_cost_fleetday + fines_cost_fleetday)

costs = w_pal_val_conf %>% 
  select(cost_per_trip_wconf)%>%
  unique()%>%
  drop_na()%>%
  pull()%>%
  sort()
# Final estimates of cost per trip (W)

W_low = costs[1] #Low Season 
W_mid = costs[2] # Mid Season
W_high = costs[3] # High Season

max_E = sum(w_par$total_fleet_days_year)

```

### C. Attempt to recover W1 and W2:

Notice that we operate under the condition that the marginal cost equals the average cost to find $W$. Now, we are trying to find a linear quadratic function in effort : 
$$
W_1 + 2W_2 E_{hist} = AC
$$

Given the lack of accurate data, we need to run a variety of analysis such that $W_1>0$, $W_2>0$ and $W_1 - AC + 2W_2  E_{Hist} = 0$, eg $W_2 = \frac{AC - W1}{2E_{Hist}}$.

```{r, recover W1 W2}
W_lq = data.frame(0,0,0,0)
colnames(W_lq) = c('Cost', 'W1', 'W2','W_mid')

for(cost in costs){
  W1 = quantile(seq(0, cost), probs = seq(0,1,.1))
  W2 = rev(quantile((cost - W1)/(2*max_E), probs = seq(0,1,.1)))
  W_mid = cost/(2*max_E)
  W_storage = data.frame(rep(cost, length(W1)), W1, W2, rep(W_mid, length(W1)))
  

  colnames(W_storage) = colnames(W_lq)
  W_lq = rbind(W_lq, W_storage)
}

W_lq = W_lq %>%
  cbind(quantiles = rownames(W_lq))%>%
  subset(W1>0)

to_keep = function(x){
  return(strsplit(x, '%')[[1]][1])
}

W_lq['quantiles'] = apply(W_lq['quantiles'],1, to_keep)

```




```{r, Load Params}
calibration = read.csv(here("data", 'outputs', "calibration_params.csv"))

for(i in 1:nrow(calibration)){
  assign(calibration$params[i], calibration$value[i])
}  


# Build the 2nd order parameters from parameter list
  # Differentiate parameters for Wild and Farmed inverse demands
alpha_w = alpha
alpha_f = alpha
beta_w = beta
beta_f = beta
  # Demand functions parameters
e   = gamma/(beta_w*beta_f - (gamma^2))
a_f = (alpha_f*beta_w - alpha_w*gamma)/(beta_w*beta_f - (gamma^2))
a_w = (alpha_w*beta_f - alpha_f*gamma)/(beta_w*beta_f - (gamma^2))
b_f = beta_f/(beta_w*beta_f - (gamma^2))
b_w = beta_w/(beta_w*beta_f - (gamma^2))

calibration %>% 
  select(-X)%>%
  mutate(value = round(value,2))%>%
  kable(row.names = F)
```

## II. Define functions
Define function where variable is either `x` i.e population stock, or `s` i.e price paid to poachers. All the parameters take default values specified in the global environment.  

* `growth(x, ...)` : logistic growth function, yields growth of population (in metric tons) 

* `pt_harvest(x,...)` : harvest (in metric tons) when trader is price taker

* `monop_harvest(x, ...)`: harvest (in metric tons) when trader is a monopolist

* `monop_harvest_lq(x, ...)`: harvest (in metric tons) when trader is a monopolist and cost structure is linear quadratic

* `cournot_harvest(x, ...)`, `bertrand_harvest(x, ...)`: harvest (in metric tons) when trader and farmer compete in *Cournot*, i.e, set quantities strategically, and *Bertrand*, i.e, set prices strategically. 

* `cournot_harvest_lq(x, ...)`, `bertrand_harvest_lq(x, ...)` : harvest  (in metric tons) when trader and farmer compete in *Cournot* i.e, set quantities strategically, and *Bertrand* i.e, set prices strategically and cost structure is linear quadratic

* `price_poachers_cournot(x, ...)`, `price_poachers_bertrand(x, ...)`: price paid to poachers (in USD/metric tons) when trader and farmer compete in *Cournot* and *Bertrand*

* `cournot_farmed(s, ...)`, `bertrand_farmed(s, ...)`: quantity farmed (in metric tons) when trader and farmer compete in *Cournot* and *Bertrand*


```{r}
growth = function(x, 
                  k.=k, 
                  r.=r){
  y = r.*x*(1-x/k.)
  return(y)
}

# I. Price taker
pt_harvest = function(x, 
                      alpha. = alpha, 
                      beta. = beta, 
                      W. = W_mid, 
                      c. = c, 
                      sigma. = sigma){
  y = ((alpha.-c.) * x^2 * sigma.^2)/(4*W. + beta. * sigma.^2 * x^2)
  return(y)
}

# II. Monopoly
monop_harvest = function(x, 
                         alpha. = alpha, 
                         c. = c, 
                         sigma. = sigma, 
                         beta. = beta, 
                         W. = W_mid){
 y = ((alpha. - c.)*sigma.^2 * x^2) / (2*beta.* sigma.^2 * x^2 + 2*W.)
 return(y)
}

monop_harvest_lq = function(x,
                            alpha. = alpha, 
                            c. = c, 
                            sigma. = sigma, 
                            beta. = beta,
                            W1. = W1,
                            W2. = W2){
  y = (sigma.^2 * x^2 * (alpha. - c.) - W1.*sigma.*x)/(2*(beta.*sigma.^2 * x^2 + W2.))
  return(y)
}


# III. Cournot

cournot_harvest = function(x, 
                             alpha_f. = alpha_f, 
                             alpha_w. = alpha_w, 
                             beta_f. = beta_f, 
                             beta_w. = beta_w, 
                             gamma. = gamma, 
                             sigma. = sigma, 
                             c. = c, 
                             v. = v, 
                             W. = W_mid){
  y = ((sigma.^2)*(x^2)*(2*beta_f.*(alpha_w. - c.) - gamma.*(alpha_f. - v.)))/(4*beta_f.*W. + (sigma.^2)*(x^2)*(4*beta_f.*beta_w. - (gamma.^2)))
  return(y)
}

cournot_harvest_lq = function(x, 
                              alpha_f. = alpha_f, 
                              alpha_w. = alpha_w, 
                              beta_f. = beta_f, 
                              beta_w. = beta_w, 
                              gamma. = gamma, 
                              sigma. = sigma, 
                              c. = c, 
                              v. = v, 
                              W1. = W1, 
                              W2. = W2){
 y = ((2*beta_f. * (alpha_w. - c.) - gamma. * (alpha_w. -v.))*sigma.^2 * x^2 - 2*beta_f.*W1.*sigma.*x)/(4*beta_f.*W2. + (4*beta_f.*beta_w. - gamma.^2)*sigma.^2 * x^2)
 return(y)
}

price_poachers_cournot = function(x,
                                  alpha_f. = alpha_f, 
                                  alpha_w. = alpha_w, 
                                  beta_f. = beta_f, 
                                  beta_w. = beta_w, 
                                  gamma. = gamma, 
                                  sigma. = sigma, 
                                  c. = c, 
                                  v. = v, 
                                  W. = W_mid){
  y = (2*W.*(2*beta_f.*(alpha_w. - c.) - gamma.*(alpha_f. - v.)))/((sigma.^2)*(x^2)*(4*beta_f.*beta_w. - gamma.^2) + 4*beta_f.*W.)
  return(y)
}

cournot_farmed = function(s, 
                            alpha_f. = alpha_f, 
                            alpha_w. = alpha_w, 
                            beta_f. = beta_f, 
                            beta_w. = beta_w, 
                            gamma. = gamma, 
                            sigma. = sigma, 
                            c. = c, 
                            v. = v){
  y = (2 * beta_w. * (alpha_f. - v.) - gamma.* (alpha_w. - (s + c.)) )/(4*beta_w.*beta_f. - gamma.^2)
  return(y)
}

# IV. Bertrand

price_poachers_bertrand = function(x, 
                                   a_f. = a_f, 
                                   a_w. = a_w, 
                                   b_f. = b_f, 
                                   b_w. = b_w, 
                                   e.  = e, 
                                   c. = c, 
                                   v. = v, 
                                   sigma. = sigma, 
                                   W. = W_mid){
  y = (2*W.*b_w.*( b_f.*(2*a_w. + e.*v.) + c.*((e.^2) - 2*b_f.*b_w.) + e.*a_f.))/((sigma.^2)*(x^2)*(4*b_f.*b_w. - (e.^2)) + 2*W.*b_w.*(2*b_w.*b_f. - (e.^2)))
  return(y)
}

bertrand_harvest = function(x,
                              sigma. = sigma, 
                              a_f. = a_f, 
                              a_w. = a_w, 
                              b_f. = b_f, 
                              b_w. = b_w, 
                              e. = e, 
                              v. = v, 
                              c. = c, 
                              W. = W_mid){
  y = ((sigma.^2)*(x^2)*b_w.*(b_f.*(2*a_w.+e.*v.) + c.*((e.^2)- 2*b_f.*b_w.) + e.*a_f.))/((sigma.^2)*(x^2)*(4*b_w.*b_f. - (e.^2)) + 2*W.*b_w.*(2*b_f.*b_w. - (e.^2)))
  return(y)
}

bertrand_harvest_lq = function(x,
                               sigma. = sigma, 
                               a_f. = a_f, 
                               a_w. = a_w, 
                               b_f. = b_f, 
                               b_w. = b_w, 
                               e. = e, 
                               v. = v, 
                               c. = c, 
                               W1. = W1, 
                               W2. = W2){
  y1 = b_w.*(sigma.^2 * x^2 *((2*a_w. +e.*v.)*b_f. + e.*a_f.) + (c. + W1. * sigma. * b_w. * x)*(e.^2 - 2*b_w. *b_f.))
  y2 = 2*W2.*b_w.*(2*b_f.* b_w. - e.^2) + (4*b_f.*b_w. - e.^2)*sigma.^2*x^2
  z = y1*y2
  return(z)
}

price_poacher_bertrand_lq = function(x,
                               sigma. = sigma, 
                               a_f. = a_f, 
                               a_w. = a_w, 
                               b_f. = b_f, 
                               b_w. = b_w, 
                               e. = e, 
                               v. = v, 
                               c. = c, 
                               W1. = W1, 
                               W2. = W2){
  y = 2*b_w.*W2.*((2*a_w. + e.*v.)*b_f. + e.*a_f. + c.*(e.^2 - b_f.*b_w.)) + W1.*sigma.*x*(4*b_f.*b_w. - e.^2)
  z = sigma.^2 * x^2 * (4*b_w.*b_f. - e.^2) + 4*b_w.*W2.*(2*b_f.*b_w - e.^2)
  result = y/z
  return(result)
}

composite_bertrand_lq = function(x,
                               sigma. = sigma, 
                               a_f. = a_f, 
                               a_w. = a_w, 
                               b_f. = b_f, 
                               b_w. = b_w, 
                               e. = e, 
                               v. = v, 
                               c. = c, 
                               W1. = W1, 
                               W2. = W2){
  y = b_w. * ((2*a_w. +e.*v.)*b_f. + e.*a_f. + (price_poacher_bertrand_lq(x)+c.)*(e.^2 - 2*b_w.*b_f))/(4*b_f.*b_w. - e.^2)
  return(y)
}

bertrand_farmed = function(s, 
                             a_f. = a_f, 
                             a_w. = a_w, 
                             b_f. = b_f, 
                             b_w. = b_w, 
                             e. = e, 
                             c. = c, 
                             v. = v){
  y = b_f. *(2*b_w.*a_f. + v.*(e.^2 - 2*b_w.*b_f.) + e.*(a_w. + (s+c.)*b_w.))/(4*b_f.*b_w. - e.^2)
  return(y)
}

```

## III. Generate results

Generate results saved at `~/data/outputs/results_post_review.csv` :

* Set cost variables using `W_lq`: each row corresponds to a cost parameter $W$, $W_1$ and $W_2$
```{r, Results}
# Initiate data storage
storage = data.frame(0,0,0,0,0,0,0,0)
colnames(storage) = c('x','names','values','AC', 'W_mid', 'W1', 'W2',"quantile")

# Run model for every W configuration
for(row in 1:nrow(W_lq)){
  W_mid = W_lq[row,4]
  W1 = W_lq[row,2]
  W2 = W_lq[row,3]
  quantile = W_lq[row,5]
  
  result1 = data.frame(x = seq(1,k,.5 ))%>%
    mutate(growth= growth(x),
           # Harvests with quadratic and linear-quadratic costs
           monop_harvest = monop_harvest(x),
           monop_harvest_lq = monop_harvest_lq(x),
           cournot_harvest = cournot_harvest(x),
           cournot_harvest_lq = cournot_harvest_lq(x),
           bertrand_harvest = bertrand_harvest(x),
           bertrand_harvest_lq = composite_bertrand_lq(x),
           # Steady states
           ss_monop = monop_harvest - growth, 
           ss_monop_lq = monop_harvest_lq - growth, 
           ss_cournot = cournot_harvest - growth, 
           ss_cournot_lq = cournot_harvest_lq - growth,
           ss_bertrand = bertrand_harvest - growth, 
           ss_bertrand_lq = bertrand_harvest_lq - growth,
           # Prices
           price_poachers_lq = price_poacher_bertrand_lq(x),
           price_poachers_bertrand = price_poachers_bertrand(x))
  
  # Put data in long format
  errr = result1 %>% 
    pivot_longer(-x, names_to = 'names', values_to = 'values')%>%
    subset(names %in% c('ss_monop',
                        'ss_monop_lq',
                        'ss_cournot',
                        'ss_cournot_lq',
                        'ss_bertrand',
                        'ss_bertrand_lq'))%>%
    subset(values > -.1)%>%
    subset(values < .1)%>%
    mutate(AC = W_lq[row,1],
           W_mid = W_mid, 
           W1 = W1, 
           W2 = W2,
           quantile = quantile)
  # Store
  storage = rbind(storage, errr)
}


# Goal is to format to have only 1 steady state value : filter out the points around the steady states. 
cost = unique(storage$AC)[2]

# Initiate storage
final_dat = data.frame(0,0,0,0,0,0,0,0,0)
colnames(final_dat) = c(colnames(storage), 'lag_sign')

# Mutate ac_quantile to have 1 combination to scan through
storage = storage %>%
  mutate(ac_quantile = paste0(AC,quantile))

# Loop over name and ac_quantile combination
for(name in unique(storage$names)){
  for(ac_quant in unique(storage$ac_quantile)){
    study = storage %>%
      subset(names == name)%>%
      subset(ac_quantile == ac_quant)%>%     # Subset data 
      mutate(lag_sign = c(0, diff(sign(values))), # Mutate to get sign change and value of steady state change
             lag_val = c(0, diff(x)))
    # Define cut vector to scan through each zone : cuts are defined as jumps in x value 
      cuts_ = which(study$lag_val>5 | study$lag_val < -5) - 1
      cuts_ = c(0,cuts_, nrow(study))
    # Use cuts vector to scan through
    for(cut in 1:(length(cuts_)-1)){
      lb_ = cuts_[cut]+1
      ub_ = cuts_[cut+1]
    
      to_check = study[lb_: ub_,]%>%
        subset(lag_sign !=0)%>%
        subset(lag_val>0)%>% # Keep only when the lag value is positive : otherwise, it means a change in sequence or type of equilibrium
        select(-c(lag_val, ac_quantile))
    
      final_dat = rbind(final_dat, to_check)
    }
  }
  
}

# Eventually, tell if equilibrium is stable using lag_sign 
final_dat = final_dat %>%
  subset(AC>0)%>%
  mutate(Stable = ifelse(lag_sign>0,'Stable', 'Unstable'))

# Save

write.csv(final_dat, here('data', 'outputs', 'results_post_review.csv'))
              
```



### Graph outputs : 

First, illustrate the new equilibria with the same $W$ value and the middle point solution for $W_1$ and $W_2$ in the linear quadratic cost of effort specification. 

```{r, New equilibrium}
W_mid    = W_lq[15,4]
W1       = W_lq[15,2]
W2       = W_lq[15,3]
quantile = W_lq[15,5]
  
result1 = data.frame(x = seq(1,k,.5 ))%>%
  mutate(growth= growth(x),
         monop_harvest = monop_harvest(x),
         monop_harvest_lq = monop_harvest_lq(x),
         cournot_harvest = cournot_harvest(x),
         cournot_harvest_lq = cournot_harvest_lq(x),
         bertrand_harvest = bertrand_harvest(x),
         bertrand_harvest_lq = composite_bertrand_lq(x),
         ss_monop = monop_harvest - growth, 
         ss_monop_lq = monop_harvest_lq - growth, 
         ss_cournot = cournot_harvest - growth, 
         ss_cournot_lq = cournot_harvest_lq - growth,
         ss_bertrand = bertrand_harvest - growth, 
         ss_bertrand_lq = bertrand_harvest_lq - growth,
         price_poachers_lq = price_poacher_bertrand_lq(x),
         price_poachers_bertrand = price_poachers_bertrand(x))
# Format:
renamer= function(x){
  if(x %in% c('monop_harvest', 'monop_harvest_lq')){
    return('Vertical Monopoly')
  }else if(x %in% c('cournot_harvest', 'cournot_harvest_lq')){
    return('Quantity adjustment')
  }else if(x %in% c('bertrand_harvest', 'bertrand_harvest_lq')){
    return('Price setting')
  }else if(x %in% c('growth')){
    return('Growth')
  }
}

renamer2 = function(x){
  checker = strsplit(x, '_')[[1]]
  if(length(checker)<3){
    return('Quadratic cost')
  }else{
    return('Linear quadratic cost')
  }
}

rounder = function(x){
  return(max(0,x))
}

dat_ = result1 %>%
  pivot_longer(-x, 
               values_to = 'values', 
               names_to = 'names')%>%
  subset(names %in% c('growth', 
                      'monop_harvest', 
                      'monop_harvest_lq', 
                      'cournot_harvest',
                      'cournot_harvest_lq', 
                      'bertrand_harvest', 
                      'bertrand_harvest_lq'))
dat_$new_names = sapply(dat_$names, renamer)
dat_$values2 = sapply(dat_$values, rounder)
dat_$cost_structure = sapply(dat_$names, renamer2)

dat_%>%
  subset(x %%2 == 0)%>%
  ggplot(aes(x = x,
             y = values2, 
             color = new_names))+
  geom_line(aes(linetype = cost_structure))+
  scale_linetype_manual(values=c("solid", "twodash"))+
  scale_color_manual(values = palette_)+
  theme_bw()+
  guides(
    color = guide_legend(
      title = " ",  # Title for the first column
      ncol = 2              # Number of columns
    ),
    linetype = guide_legend(
      title = ' ',
      ncol = 2
    ))+
  xlab('Population')+
  ylab('Harvest')+
  theme(legend.position = 'bottom',
        strip.text.x  = element_text(family = font_) ,
        axis.title.x  = element_text(family = font_),
        axis.text = element_text(family = font_),
        axis.title.y  = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))


```


```{r, Equilibria}
# Rename:
rename_W = function(x){
  if(x==costs[1]){
    return('Low Effort Cost')
  }else if(x==costs[2]){
    return('Mid. Effort Cost')
  }else if(x==costs[3]){
    return('High Effort Cost')
  }
}

rename_scenario = function(x){
  if(x %in% c('ss_monop_lq', 'ss_bertrand_lq', 'ss_cournot_lq')){
    return('Linear-Quadratic cost ')
  }else{
    return('Quadratic cost')
  }
}

rename_scenario2 = function(x){
  if(x %in% c('ss_bertrand', 'ss_bertrand_lq')){
    return('Bertrand')
  }else if(x %in% c('ss_cournot', 'ss_cournot_lq')){
    return('Cournot')
  }else if(x %in% c('ss_monop_lq', 'ss_monop')){
    return('Monopoly')
  }
}
rename_quantiles = function(x){
  return(paste0(x,'%'))
}


##### Final Graphs
final_dat %>%
  subset(AC>0)%>%
  subset(names %in% c('ss_monop_lq', 'ss_monop'))%>%
  mutate(new_AC = factor(sapply(AC, rename_W), 
                         levels = c('Low Effort Cost', 
                                    'Mid. Effort Cost', 
                                    'High Effort Cost')),
         new_names = sapply(names, rename_scenario),
         tamr = paste(new_names, new_AC, sep = ' '),
         new_quantile = sapply(quantile, rename_quantiles))%>%
  subset(new_quantile %in% c('10%','20%', '50%', '80%','90%'))%>%
  ggplot(aes(x = new_names, y = x, color = Stable))+
  scale_color_manual(values = c('darkblue', 'brown'))+
  geom_point(size = 2)+
  #scale_color_continuous('Estimate of unit effort cost', type = 'viridis')+
  facet_grid(new_AC~new_quantile)+
  theme_bw()+
  xlab(' ')+
  ylab(' ')+
  ggtitle("Vertical monopoly steady states with linear and linear quadratic costs")+
  theme(axis.text.x = element_text(angle = 60, 
                                   hjust = 1,
                                   family = font_), 
        axis.title.x= element_text(family = font_),
        axis.title.y = element_text(family = font_),
        plot.title = element_text(hjust = 0.5,
                                  family = font_),
        strip.text.x  = element_text(family = font_) ,
        axis.text = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))
```

```{r, Cournot}

final_dat %>%
  subset(AC>0)%>%
  subset(names %in% c('ss_cournot_lq', 'ss_cournot'))%>%
  mutate(new_AC = factor(sapply(AC, rename_W), 
                         levels = c('Low Effort Cost', 
                                    'Mid. Effort Cost', 
                                    'High Effort Cost')),
         new_names = sapply(names, rename_scenario),
         tamr = paste(new_names, new_AC, sep = ' '),
         new_quantile = sapply(quantile, rename_quantiles))%>%
  subset(new_quantile %in% c('10%','20%', '50%', '80%','90%'))%>%
  ggplot(aes(x = new_names, y = x, color = Stable))+
  scale_color_manual(values = c('darkblue', 'brown'))+
  geom_point(size = 2)+
  #scale_color_continuous('Estimate of unit effort cost', type = 'viridis')+
  facet_grid(new_AC~new_quantile)+
  theme_bw()+
  xlab(' ')+
  ylab(' ')+
  ggtitle("Quantity adjustment steady states with linear and linear quadratic costs")+
  theme(axis.text.x = element_text(angle = 60, 
                                   hjust = 1,
                                   family = font_), 
        axis.title.x= element_text(family = font_),
        axis.title.y = element_text(family = font_),
        plot.title = element_text(hjust = 0.5,
                                  family = font_),
        strip.text.x  = element_text(family = font_) ,
        axis.text = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))
```

```{r, Bertrand}
final_dat %>%
  subset(AC>0)%>%
  subset(names %in% c('ss_bertrand_lq', 'ss_bertrand'))%>%
  mutate(new_AC = factor(sapply(AC, rename_W), 
                         levels = c('Low Effort Cost', 
                                    'Mid. Effort Cost', 
                                    'High Effort Cost')),
         new_names = sapply(names, rename_scenario),
         tamr = paste(new_names, new_AC, sep = ' '),
         new_quantile = sapply(quantile, rename_quantiles))%>%
  subset(new_quantile %in% c('10%','20%', '50%', '80%','90%'))%>%
  ggplot(aes(x = new_names, y = x, color = Stable))+
  scale_color_manual(values = c('darkblue', 'brown'))+
  geom_point(size = 2)+
  #scale_color_continuous('Estimate of unit effort cost', type = 'viridis')+
  facet_grid(new_AC~new_quantile)+
  theme_bw()+
  xlab(' ')+
  ylab(' ')+
  ggtitle("Price setting steady states with linear and linear quadratic costs")+
  theme(axis.text.x = element_text(angle = 60, 
                                   hjust = 1,
                                   family = font_), 
        axis.title.x= element_text(family = font_),
        axis.title.y = element_text(family = font_),
        plot.title = element_text(hjust = 0.5,
                                  family = font_),
        strip.text.x  = element_text(family = font_) ,
        axis.text = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))


```
### IV. Include profitability

In this section : 

* Define profit functions 

* Check the profit at steady state levels

* Compare with baseline scenario

```{r, define profitability}

profit = function(x, 
                  cost_structure,
                  scenario,
                  player,
                  alpha_f. = alpha_f,
                  alpha_w. = alpha_w,
                  beta_f. = beta_f,
                  beta_w. = beta_w,
                  gamma. = gamma, 
                  sigma. = sigma, 
                  c. = c, 
                  v. = v, 
                  W1. = W1, 
                  W2. = W2,
                  a_f. = a_f,
                  a_w. = a_w,
                  b_f. = b_f,
                  b_w. = b_w,
                  e. = e){
  if(scenario %in% c('Bertrand', 'bertrand')){
    if(cost_structure %in% c('linear quadratic', 'Linear quadratic')){
     if(player == 'illegal'){
       return('In Bertrand equilibrium with linear quadratic costs, profit of the illegal sector is XXX')
     }else if(player == 'aquaculture'){
       return('In Bertrand equilibrium with linear quadratic costs, profit of the aquaculture sector is XXX')
     } 
    }else if(cost_structure %in% c('quadratic', 'Quadratic')){
    if(player == 'illegal'){
       return('In Bertrand equilibrium with quadratic costs, profit of the illegal sector is XXX')
     }else if(player == 'aquaculture'){
       return('In Bertrand equilibrium with  quadratic costs, profit of the aquaculture sector is XXX')
     } 
  }
  }else if(scenario %in% c('Cournot', 'cournot')){
    if(cost_structure %in% c('linear quadratic', 'Linear quadratic')){
      if(player == 'illegal'){
       return('In Cournot equilibrium with linear quadratic costs, profit of the illegal sector is XXX')
      }else if(player == 'aquaculture'){
       return('In Cournot equilibrium with quadratic costs, profit of the aquaculture sector is XXX')
     } 
    }else if(cost_structure %in% c('quadratic', 'Quadratic')){
    if(player == 'illegal'){
       return('In Bertrand equilibrium with quadratic costs, profit of the illegal sector is XXX')
     }else if(player == 'aquaculture'){
       return('In Bertrand equilibrium with quadratic costs, profit of the aquaculture sector is XXX')
     } 
    }
  }else if(scenario %in% c('Monopoly', 'monopoly')){
    if(cost_structure %in% c('linear quadratic', 'Linear quadratic')){
       return('In the vertical monopoly equilibrium with linear quadratic costs, profit of the illegal sector is XXX')
     }else if(cost_structure %in% c('quadratic', 'Quadratic')){
       return('In the vertical monopoly equilibrium with quadratic costs, profit of the illegal sector is XXX')
     } 
  }else{
    return('Scenario, cost structure or player is not well referenced : check the syntax of the function')
  }
}



```


#Run sensitivity analysis for linear quadratic model

In this section : 

* Define the scenarios to run sensitivity analysis on: use the sensitivity table used previously and interpolate with `W_lq`

* Run all the analysis

* Identify the parameter spaces for which the targets of (i) improving stock and (ii) maintaining profitability are **met** or not

```{r, sensitivity analysis}
rm(dat_,
   result1)

params_sensitivity = read.csv(here('data', 'inputs', 'params_sensitivity.csv'))

new_params_sensitivity = data.frame(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
colnames(new_params_sensitivity) = c(colnames(params_sensitivity), 'W1', 'W2', 'quantile')

for(row in 1:nrow(params_sensitivity)){
  W = params_sensitivity[row, 'W']
  cost = 2*max_E*W
  W1 = quantile(seq(0, cost), probs = seq(0,1,.1))
  W2 = rev(quantile((cost - W1)/(2*max_E), probs = seq(0,1,.1)))
  
  to_append = data.frame(W, W1, W2)
  
  to_append = to_append %>% 
    mutate(quantile = rownames(to_append))%>%
    select(-W)
  rownames(to_append) = NULL
  
  a = cbind(params_sensitivity[rep(row, nrow(to_append)),], to_append)
  
  new_params_sensitivity = rbind(new_params_sensitivity, a)
}

write.csv(new_params_sensitivity, here('data', 'inputs', 'params_sensitivity_lq.csv'))
```

