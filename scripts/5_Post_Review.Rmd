---
title: "5_Post Review"
author: "Simon"
date: "2024-01-09"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
options(scipen=999)

rm(list = ls())

library(tidyverse)
library("ggsci")
library(here)
library(knitr)
library(stargazer)
library(parallel)
library(RColorBrewer)

if(!('Fishlife' %in% installed.packages())){
  devtools::install_github("james-thorson/FishLife")
}
library(FishLife)
library(kableExtra)

Latex =T
font_ = 'Helvetica'
color_growth = 'black'
color_vertical_monopoly = 'firebrick'
color_bertrand = '#1f78b4'
color_cournot = 'forestgreen'
palette_ = c(color_growth, color_vertical_monopoly, color_bertrand, color_cournot)
```

# Model with linear quadratic costs

## I. Recover W
### A. Load data
Use the same data as in `1_Parameters.rmd`.
```{r, Load data}
dat_p = read.csv(here("data","inputs","dat_p.csv")) #Price-quantity data (OG Paper)
dat_p = dat_p %>%
  mutate(price_buche = g*p,
         price_kg = p*1000, 
         price_buche_kg = price_buche*1000)


dat_b = read.csv(here('data', 'inputs', "totoaba_biomass_catch_20230516.csv")) %>% 
  rename(y = X) %>% 
  rename(b = Biomass..Tonnes.) %>% 
  rename(c = Catch..Tonnes.)

w_par = read.csv(here("data", 'inputs', "w_par.csv"))
v_par = read.csv(here("data", 'inputs', "v_par.csv")) 

sources = read.csv(here("data", 'inputs', "sources.csv"))

```


### B. Calculate W
Calculate costs of poaching using the same method as in `1_Parameters.rmd`. 
```{r calculating cost of poaching}

# W parameter, proportional increase in cost per unit (trip)

#Step one, get all annual operating costs
# Goal is to calculate cost per vessel trip (we have total fleet days per year which is number of vessels * fishing days per month)
# First calculate total annual costs for the entire fleet

w_par_ops <- w_par %>% 
  mutate(cost_crew_earnings = (totoaba_year * price_fishers_per_totoaba * monthly_earnings_paid)) %>% 
  mutate(cost_food_fuel = (foodfuel_day * total_fleet_days_year)) %>% 
  mutate(cost_gear = total_fleet_days_year*(gear_loss_day*gear_replacement)) %>% 
  mutate(revenue_per_month = (totoaba_year*(price_fishers_per_totoaba)) - (cost_crew_earnings-cost_food_fuel-cost_gear))

# Next, divide by total fishing days per year

w_par_val <- w_par_ops %>% 
  select(vessels, totoaba_day, total_fleet_days_year,cost_crew_earnings,cost_food_fuel,cost_gear,bribes_year,revenue_per_month) %>% 
  mutate(cost_per_trip = (cost_crew_earnings + cost_food_fuel + cost_gear + bribes_year)/total_fleet_days_year) 

#Adding in gear and vessel confiscation (calculated as a shared cost applied to the entire fleet)

w_pal_val_conf <- w_par_val %>%
  add_column(net_confs_cost_fleetday=664000/1920) %>% #Total cost as a proportion of reported confiscations averaged over the year (1,920 fishing trips total). 5,720 nets in the water each year (each vessel sets 2-3 nets), and 0.07 of those nets are confiscated (we know that there are 415 gear confiscation events each year). So if we assume that each net costs $1,600, then our total cost to the fleet is $664,000.
  add_column(vessel_confs_cost_fleetday=1230000/1920) %>% #Total cost as a proportion of reported vessel seizures averaged over the year (1,920 fishing trips total). There are 150 boats in total each year, and 0.546 are confiscated (there are 82 confiscations a year). So we assume each boat is worth $15,000, and therefore the total cost to the fleet is $1,230,000.
  add_column(fines_cost_fleetday=81675/1920) %>% #Total cost as a proportion of reported vessel seizures averaged over the year (1,920 fishing trips total). There are 11 arrests/convictions where people are fined $7,425/event, which would add an additional cost of $42.54.
  mutate(cost_per_trip = (cost_crew_earnings + cost_food_fuel + cost_gear + bribes_year)/total_fleet_days_year) %>% 
  mutate(cost_per_trip_wconf = cost_per_trip + net_confs_cost_fleetday + vessel_confs_cost_fleetday + fines_cost_fleetday)

costs = w_pal_val_conf %>% 
  select(cost_per_trip_wconf)%>%
  unique()%>%
  drop_na()%>%
  pull()%>%
  sort()
# Final estimates of cost per trip (W)

W_low = costs[1] #Low Season 
W_mid = costs[2] # Mid Season
W_high = costs[3] # High Season

max_E = sum(w_par$total_fleet_days_year)

```

### C. Attempt to recover W1 and W2:

Notice that we operate under the condition that the marginal cost equals the average cost to find $W$. Now, we are trying to find a linear quadratic function in effort : 
$$
W_1 + 2W_2 E_{hist} = AC
$$

Given the lack of accurate data, we need to run a variety of analysis such that $W_1>0$, $W_2>0$ and $W_1 - AC + 2W_2  E_{Hist} = 0$, eg $W_2 = \frac{AC - W1}{2E_{Hist}}$.

```{r, recover W1 W2}
W_lq = data.frame(0,0,0,0)
colnames(W_lq) = c('Cost', 'W1', 'W2','W_mid')

for(cost in costs){
  W1 = quantile(seq(0, cost), probs = seq(0,1,.1))
  W2 = rev(quantile((cost - W1)/(2*max_E), probs = seq(0,1,.1)))
  W_mid = cost/(2*max_E)
  W_storage = data.frame(rep(cost, length(W1)), W1, W2, rep(W_mid, length(W1)))
  

  colnames(W_storage) = colnames(W_lq)
  W_lq = rbind(W_lq, W_storage)
}

W_lq = W_lq %>%
  cbind(quantiles = rownames(W_lq))%>%
  subset(W1>0)

to_keep = function(x){
  return(strsplit(x, '%')[[1]][1])
}

W_lq['quantiles'] = apply(W_lq['quantiles'],1, to_keep)

```




```{r, Load Params}
calibration = read.csv(here("data", 'outputs', "calibration_params.csv"))

for(i in 1:nrow(calibration)){
  assign(calibration$params[i], calibration$value[i])
}  


# Build the 2nd order parameters from parameter list
  # Differentiate parameters for Wild and Farmed inverse demands
alpha_w = alpha
alpha_f = alpha
beta_w = beta
beta_f = beta
  # Demand functions parameters
e   = gamma/(beta_w*beta_f - (gamma^2))
a_f = (alpha_f*beta_w - alpha_w*gamma)/(beta_w*beta_f - (gamma^2))
a_w = (alpha_w*beta_f - alpha_f*gamma)/(beta_w*beta_f - (gamma^2))
b_f = beta_f/(beta_w*beta_f - (gamma^2))
b_w = beta_w/(beta_w*beta_f - (gamma^2))

calibration %>% 
  select(-X)%>%
  mutate(value = round(value,2))%>%
  kable(row.names = F)
```

## II. Define functions
Define function where variable is either `x` i.e population stock, or `s` i.e price paid to poachers. All the parameters take default values specified in the global environment.  

* `growth(x, ...)` : logistic growth function, yields growth of population (in metric tons) 

* `pt_harvest(x,...)` : harvest (in metric tons) when trader is price taker

* `monop_harvest(x, ...)`: harvest (in metric tons) when trader is a monopolist

* `monop_harvest_lq(x, ...)`: harvest (in metric tons) when trader is a monopolist and cost structure is linear quadratic

* `cournot_harvest(x, ...)`, `bertrand_harvest(x, ...)`: harvest (in metric tons) when trader and farmer compete in *Cournot*, i.e, set quantities strategically, and *Bertrand*, i.e, set prices strategically. 

* `cournot_harvest_lq(x, ...)`, `bertrand_harvest_lq(x, ...)` : harvest  (in metric tons) when trader and farmer compete in *Cournot* i.e, set quantities strategically, and *Bertrand* i.e, set prices strategically and cost structure is linear quadratic

* `price_poachers_cournot(x, ...)`, `price_poachers_bertrand(x, ...)`: price paid to poachers (in USD/metric tons) when trader and farmer compete in *Cournot* and *Bertrand*

* `cournot_farmed(s, ...)`, `bertrand_farmed(s, ...)`: quantity farmed (in metric tons) when trader and farmer compete in *Cournot* and *Bertrand*


```{r}
growth = function(x, 
                  k.=k, 
                  r.=r){
  y = r.*x*(1-x/k.)
  return(y)
}

# I. Price taker
pt_harvest = function(x, 
                      alpha. = alpha, 
                      beta. = beta, 
                      W. = W_mid, 
                      c. = c, 
                      sigma. = sigma){
  y = ((alpha.-c.) * x^2 * sigma.^2)/(4*W. + beta. * sigma.^2 * x^2)
  return(y)
}

# II. Monopoly
monop_harvest = function(x, 
                         alpha. = alpha, 
                         c. = c, 
                         sigma. = sigma, 
                         beta. = beta, 
                         W. = W_mid){
 y = ((alpha. - c.)*sigma.^2 * x^2) / (2*beta.* sigma.^2 * x^2 + 2*W.)
 return(y)
}

monop_harvest_lq = function(x,
                            alpha. = alpha, 
                            c. = c, 
                            sigma. = sigma, 
                            beta. = beta,
                            W1. = W1,
                            W2. = W2){
  y = (sigma.^2 * x^2 * (alpha. - c.) - W1.*sigma.*x)/(2*(beta.*sigma.^2 * x^2 + W2.))
  return(y)
}


# III. Cournot

cournot_harvest = function(x, 
                             alpha_f. = alpha_f, 
                             alpha_w. = alpha_w, 
                             beta_f. = beta_f, 
                             beta_w. = beta_w, 
                             gamma. = gamma, 
                             sigma. = sigma, 
                             c. = c, 
                             v. = v, 
                             W. = W_mid){
  y = ((sigma.^2)*(x^2)*(2*beta_f.*(alpha_w. - c.) - gamma.*(alpha_f. - v.)))/(4*beta_f.*W. + (sigma.^2)*(x^2)*(4*beta_f.*beta_w. - (gamma.^2)))
  return(y)
}

cournot_harvest_lq = function(x, 
                              alpha_f. = alpha_f, 
                              alpha_w. = alpha_w, 
                              beta_f. = beta_f, 
                              beta_w. = beta_w, 
                              gamma. = gamma, 
                              sigma. = sigma, 
                              c. = c, 
                              v. = v, 
                              W1. = W1, 
                              W2. = W2){
 y = ((2*beta_f. * (alpha_w. - c.) - gamma. * (alpha_w. -v.))*sigma.^2 * x^2 - 2*beta_f.*W1.*sigma.*x)/(4*beta_f.*W2. + (4*beta_f.*beta_w. - gamma.^2)*sigma.^2 * x^2)
 return(y)
}

price_poachers_cournot = function(x,
                                  alpha_f. = alpha_f, 
                                  alpha_w. = alpha_w, 
                                  beta_f. = beta_f, 
                                  beta_w. = beta_w, 
                                  gamma. = gamma, 
                                  sigma. = sigma, 
                                  c. = c, 
                                  v. = v, 
                                  W. = W_mid){
  y = (2*W.*(2*beta_f.*(alpha_w. - c.) - gamma.*(alpha_f. - v.)))/((sigma.^2)*(x^2)*(4*beta_f.*beta_w. - gamma.^2) + 4*beta_f.*W.)
  return(y)
}

cournot_farmed = function(s, 
                            alpha_f. = alpha_f, 
                            alpha_w. = alpha_w, 
                            beta_f. = beta_f, 
                            beta_w. = beta_w, 
                            gamma. = gamma, 
                            sigma. = sigma, 
                            c. = c, 
                            v. = v){
  y = (2 * beta_w. * (alpha_f. - v.) - gamma.* (alpha_w. - (s + c.)) )/(4*beta_w.*beta_f. - gamma.^2)
  return(y)
}

# IV. Bertrand

price_poachers_bertrand = function(x, 
                                   a_f. = a_f, 
                                   a_w. = a_w, 
                                   b_f. = b_f, 
                                   b_w. = b_w, 
                                   e.  = e, 
                                   c. = c, 
                                   v. = v, 
                                   sigma. = sigma, 
                                   W. = W_mid){
  y = (2*W.*b_w.*( b_f.*(2*a_w. + e.*v.) + c.*((e.^2) - 2*b_f.*b_w.) + e.*a_f.))/((sigma.^2)*(x^2)*(4*b_f.*b_w. - (e.^2)) + 2*W.*b_w.*(2*b_w.*b_f. - (e.^2)))
  return(y)
}

bertrand_harvest = function(x,
                              sigma. = sigma, 
                              a_f. = a_f, 
                              a_w. = a_w, 
                              b_f. = b_f, 
                              b_w. = b_w, 
                              e. = e, 
                              v. = v, 
                              c. = c, 
                              W. = W_mid){
  y = ((sigma.^2)*(x^2)*b_w.*(b_f.*(2*a_w.+e.*v.) + c.*((e.^2)- 2*b_f.*b_w.) + e.*a_f.))/((sigma.^2)*(x^2)*(4*b_w.*b_f. - (e.^2)) + 2*W.*b_w.*(2*b_f.*b_w. - (e.^2)))
  return(y)
}

bertrand_harvest_lq = function(x,
                               sigma. = sigma, 
                               a_f. = a_f, 
                               a_w. = a_w, 
                               b_f. = b_f, 
                               b_w. = b_w, 
                               e. = e, 
                               v. = v, 
                               c. = c, 
                               W1. = W1, 
                               W2. = W2){
  y1 = b_w.*(sigma.^2 * x^2 *((2*a_w. +e.*v.)*b_f. + e.*a_f.) + (c. + W1. * sigma. * b_w. * x)*(e.^2 - 2*b_w. *b_f.))
  y2 = 2*W2.*b_w.*(2*b_f.* b_w. - e.^2) + (4*b_f.*b_w. - e.^2)*sigma.^2*x^2
  z = y1*y2
  return(z)
}

price_poacher_bertrand_lq = function(x,
                               sigma. = sigma, 
                               a_f. = a_f, 
                               a_w. = a_w, 
                               b_f. = b_f, 
                               b_w. = b_w, 
                               e. = e, 
                               v. = v, 
                               c. = c, 
                               W1. = W1, 
                               W2. = W2){
  y = 2*b_w.*W2.*((2*a_w. + e.*v.)*b_f. + e.*a_f. + c.*(e.^2 - b_f.*b_w.)) + W1.*sigma.*x*(4*b_f.*b_w. - e.^2)
  z = sigma.^2 * x^2 * (4*b_w.*b_f. - e.^2) + 4*b_w.*W2.*(2*b_f.*b_w - e.^2)
  result = y/z
  return(result)
}

composite_bertrand_lq = function(x,
                               sigma. = sigma, 
                               a_f. = a_f, 
                               a_w. = a_w, 
                               b_f. = b_f, 
                               b_w. = b_w, 
                               e. = e, 
                               v. = v, 
                               c. = c, 
                               W1. = W1, 
                               W2. = W2){
  y = b_w. * ((2*a_w. +e.*v.)*b_f. + e.*a_f. + (price_poacher_bertrand_lq(x)+c.)*(e.^2 - 2*b_w.*b_f))/(4*b_f.*b_w. - e.^2)
  return(y)
}

bertrand_farmed = function(s, 
                             a_f. = a_f, 
                             a_w. = a_w, 
                             b_f. = b_f, 
                             b_w. = b_w, 
                             e. = e, 
                             c. = c, 
                             v. = v){
  y = b_f. *(2*b_w.*a_f. + v.*(e.^2 - 2*b_w.*b_f.) + e.*(a_w. + (s+c.)*b_w.))/(4*b_f.*b_w. - e.^2)
  return(y)
}

```

## III. Generate results

Generate results saved at `~/data/outputs/results_post_review.csv` :

* Set cost variables using `W_lq`: each row corresponds to a cost parameter $W$, $W_1$ and $W_2$
```{r, Results}
# Initiate data storage
storage = data.frame(0,0,0,0,0,0,0,0)
colnames(storage) = c('x','names','values','AC', 'W_mid', 'W1', 'W2',"quantile")

# Run model for every W configuration
for(row in 1:nrow(W_lq)){
  W_mid = W_lq[row,4]
  W1 = W_lq[row,2]
  W2 = W_lq[row,3]
  quantile = W_lq[row,5]
  
  result1 = data.frame(x = seq(1,k,.5 ))%>%
    mutate(growth= growth(x),
           # Harvests with quadratic and linear-quadratic costs
           monop_harvest = monop_harvest(x),
           monop_harvest_lq = monop_harvest_lq(x),
           cournot_harvest = cournot_harvest(x),
           cournot_harvest_lq = cournot_harvest_lq(x),
           bertrand_harvest = bertrand_harvest(x),
           bertrand_harvest_lq = composite_bertrand_lq(x),
           # Steady states
           ss_monop = monop_harvest - growth, 
           ss_monop_lq = monop_harvest_lq - growth, 
           ss_cournot = cournot_harvest - growth, 
           ss_cournot_lq = cournot_harvest_lq - growth,
           ss_bertrand = bertrand_harvest - growth, 
           ss_bertrand_lq = bertrand_harvest_lq - growth,
           # Prices
           price_poachers_lq = price_poacher_bertrand_lq(x),
           price_poachers_bertrand = price_poachers_bertrand(x))
  
  # Put data in long format
  errr = result1 %>% 
    pivot_longer(-x, names_to = 'names', values_to = 'values')%>%
    subset(names %in% c('ss_monop',
                        'ss_monop_lq',
                        'ss_cournot',
                        'ss_cournot_lq',
                        'ss_bertrand',
                        'ss_bertrand_lq'))%>%
    subset(values > -.1)%>%
    subset(values < .1)%>%
    mutate(AC = W_lq[row,1],
           W_mid = W_mid, 
           W1 = W1, 
           W2 = W2,
           quantile = quantile)
  # Store
  storage = rbind(storage, errr)
}


# Goal is to format to have only 1 steady state value : filter out the points around the steady states. 
cost = unique(storage$AC)[2]

# Initiate storage
final_dat = data.frame(0,0,0,0,0,0,0,0,0)
colnames(final_dat) = c(colnames(storage), 'lag_sign')

# Mutate ac_quantile to have 1 combination to scan through
storage = storage %>%
  mutate(ac_quantile = paste0(AC,quantile))

# Loop over name and ac_quantile combination
for(name in unique(storage$names)){
  for(ac_quant in unique(storage$ac_quantile)){
    study = storage %>%
      subset(names == name)%>%
      subset(ac_quantile == ac_quant)%>%     # Subset data 
      mutate(lag_sign = c(0, diff(sign(values))), # Mutate to get sign change and value of steady state change
             lag_val = c(0, diff(x)))
    # Define cut vector to scan through each zone : cuts are defined as jumps in x value 
      cuts_ = which(study$lag_val>5 | study$lag_val < -5) - 1
      cuts_ = c(0,cuts_, nrow(study))
    # Use cuts vector to scan through
    for(cut in 1:(length(cuts_)-1)){
      lb_ = cuts_[cut]+1
      ub_ = cuts_[cut+1]
    
      to_check = study[lb_: ub_,]%>%
        subset(lag_sign !=0)%>%
        subset(lag_val>0)%>% # Keep only when the lag value is positive : otherwise, it means a change in sequence or type of equilibrium
        select(-c(lag_val, ac_quantile))
    
      final_dat = rbind(final_dat, to_check)
    }
  }
  
}

# Eventually, tell if equilibrium is stable using lag_sign 
final_dat = final_dat %>%
  subset(AC>0)%>%
  mutate(Stable = ifelse(lag_sign>0,'Stable', 'Unstable'))

# Save

write.csv(final_dat, here('data', 'outputs', 'results_post_review.csv'))
              
```



### Graph outputs : 

First, illustrate the new equilibria with the same $W$ value and the middle point solution for $W_1$ and $W_2$ in the linear quadratic cost of effort specification. 

```{r, New equilibrium}
W_mid    = W_lq[21,4]
W1       = W_lq[21,2]
W2       = W_lq[21,3]
quantile = W_lq[21,5]
  
result1 = data.frame(x = seq(1,k,.5 ))%>%
  mutate(growth= growth(x),
         monop_harvest = monop_harvest(x),
         monop_harvest_lq = monop_harvest_lq(x),
         cournot_harvest = cournot_harvest(x),
         cournot_harvest_lq = cournot_harvest_lq(x),
         bertrand_harvest = bertrand_harvest(x),
         bertrand_harvest_lq = composite_bertrand_lq(x),
         ss_monop = monop_harvest - growth, 
         ss_monop_lq = monop_harvest_lq - growth, 
         ss_cournot = cournot_harvest - growth, 
         ss_cournot_lq = cournot_harvest_lq - growth,
         ss_bertrand = bertrand_harvest - growth, 
         ss_bertrand_lq = bertrand_harvest_lq - growth,
         price_poachers_lq = price_poacher_bertrand_lq(x),
         price_poachers_bertrand = price_poachers_bertrand(x))
# Format:
renamer= function(x){
  if(x %in% c('monop_harvest', 'monop_harvest_lq')){
    return('Vertical Monopoly')
  }else if(x %in% c('cournot_harvest', 'cournot_harvest_lq')){
    return('Quantity adjustment')
  }else if(x %in% c('bertrand_harvest', 'bertrand_harvest_lq')){
    return('Price setting')
  }else if(x %in% c('growth')){
    return('Growth')
  }
}

renamer2 = function(x){
  checker = strsplit(x, '_')[[1]]
  if(length(checker)<3){
    return('Quadratic cost')
  }else{
    return('Linear quadratic cost')
  }
}

rounder = function(x){
  return(max(0,x))
}

dat_ = result1 %>%
  pivot_longer(-x, 
               values_to = 'values', 
               names_to = 'names')%>%
  subset(names %in% c('growth', 
                      'monop_harvest', 
                      'monop_harvest_lq', 
                      'cournot_harvest',
                      'cournot_harvest_lq', 
                      'bertrand_harvest', 
                      'bertrand_harvest_lq'))
dat_$new_names = sapply(dat_$names, renamer)
dat_$values2 = sapply(dat_$values, rounder)
dat_$cost_structure = sapply(dat_$names, renamer2)

dat_%>%
  subset(x %%2 == 0)%>%
  ggplot(aes(x = x,
             y = values2, 
             color = new_names))+
  geom_line(aes(linetype = cost_structure))+
  scale_linetype_manual(values=c("solid", "twodash"))+
  scale_color_manual(values = palette_)+
  theme_bw()+
  guides(
    color = guide_legend(
      title = " ",  # Title for the first column
      ncol = 2              # Number of columns
    ),
    linetype = guide_legend(
      title = ' ',
      ncol = 2
    ))+
  xlab('Population')+
  ylab('Harvest')+
  theme(legend.position = 'bottom',
        strip.text.x  = element_text(family = font_) ,
        axis.title.x  = element_text(family = font_),
        axis.text = element_text(family = font_),
        axis.title.y  = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))


```

To understand the impact of different $W_1$ & $W_2$ divides : 

```{r, understand different W}
store = data.frame(matrix(nrow = 0, ncol= ncol(result1)+1))
colnames(store)= c(colnames(result1), 'quantile')

for(xx in c(21, 25, 29)){
  W_mid    = W_lq[xx,4]
  W1       = W_lq[xx,2]
  W2       = W_lq[xx,3]
  quantile = W_lq[xx,5]
  
  result1 = data.frame(x = seq(1,k,.5 ))%>%
    mutate(growth= growth(x),
           monop_harvest = monop_harvest(x),
           monop_harvest_lq = monop_harvest_lq(x),
           cournot_harvest = cournot_harvest(x),
           cournot_harvest_lq = cournot_harvest_lq(x),
           bertrand_harvest = bertrand_harvest(x),
           bertrand_harvest_lq = composite_bertrand_lq(x),
           ss_monop = monop_harvest - growth, 
           ss_monop_lq = monop_harvest_lq - growth, 
           ss_cournot = cournot_harvest - growth, 
           ss_cournot_lq = cournot_harvest_lq - growth,
           ss_bertrand = bertrand_harvest - growth, 
           ss_bertrand_lq = bertrand_harvest_lq - growth,
           price_poachers_lq = price_poacher_bertrand_lq(x),
           price_poachers_bertrand = price_poachers_bertrand(x),
           quantile = paste0('W1 =', round(W1,1), ' & W2 = ', round(W2,1)))
  store = rbind(store, 
                result1)
}

store$quantile = factor(store$quantile, levels = c("W1 =12947.4 & W2 = 0.4",
                                                   "W1 =7193 & W2 = 1.9",
                                                   "W1 =1438.6 & W2 = 3.4"))

# Format:
renamer= function(x){
  if(x %in% c('monop_harvest', 'monop_harvest_lq')){
    return('Vertical Monopoly')
  }else if(x %in% c('cournot_harvest', 'cournot_harvest_lq')){
    return('Quantity adjustment')
  }else if(x %in% c('bertrand_harvest', 'bertrand_harvest_lq')){
    return('Price setting')
  }else if(x %in% c('growth')){
    return('Growth')
  }
}

renamer2 = function(x){
  checker = strsplit(x, '_')[[1]]
  if(length(checker)<3){
    return('Quadratic cost')
  }else{
    return('Linear quadratic cost')
  }
}

rounder = function(x){
  return(max(0,x))
}

dat_ = store %>%
  pivot_longer(-c(x,quantile), 
               values_to = 'values', 
               names_to = 'names')%>%
  subset(names %in% c('growth', 
                      'monop_harvest', 
                      'monop_harvest_lq', 
                      'cournot_harvest',
                      'cournot_harvest_lq', 
                      'bertrand_harvest', 
                      'bertrand_harvest_lq'))
dat_$new_names = sapply(dat_$names, renamer)
dat_$values2 = sapply(dat_$values, rounder)
dat_$cost_structure = sapply(dat_$names, renamer2)

dat_%>%
  subset(x %% 2 == 0)%>%
  ggplot(aes(x = x,
             y = values2, 
             color = new_names))+
  geom_line(aes(linetype = cost_structure), linewidth = 1)+
  facet_grid(~quantile)+
  scale_linetype_manual(values=c("twodash", "solid"))+
  scale_color_manual(values = palette_)+
  theme_bw()+
  guides(
    color = guide_legend(
      title = " ",  # Title for the first column
      ncol = 2              # Number of columns
    ),
    linetype = guide_legend(
      title = ' ',
      ncol = 2
    ))+
  xlab('Population')+
  ylab('Harvest')+
  theme(legend.position = 'bottom',
        strip.text.x  = element_text(family = font_) ,
        axis.title.x  = element_text(family = font_),
        axis.text = element_text(family = font_),
        axis.title.y  = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))
```


```{r, Equilibria}
# Rename:
rename_W = function(x){
  if(x==costs[1]){
    return('Low Effort Cost')
  }else if(x==costs[2]){
    return('Mid. Effort Cost')
  }else if(x==costs[3]){
    return('High Effort Cost')
  }
}

rename_scenario = function(x){
  if(x %in% c('ss_monop_lq', 'ss_bertrand_lq', 'ss_cournot_lq')){
    return('Linear-Quadratic cost ')
  }else{
    return('Quadratic cost')
  }
}

rename_scenario2 = function(x){
  if(x %in% c('ss_bertrand', 'ss_bertrand_lq')){
    return('Bertrand')
  }else if(x %in% c('ss_cournot', 'ss_cournot_lq')){
    return('Cournot')
  }else if(x %in% c('ss_monop_lq', 'ss_monop')){
    return('Monopoly')
  }
}
rename_quantiles = function(x){
  return(paste0(x,'%'))
}


##### Final Graphs
final_dat %>%
  subset(AC>0)%>%
  subset(names %in% c('ss_monop_lq', 'ss_monop'))%>%
  mutate(new_AC = factor(sapply(AC, rename_W), 
                         levels = c('Low Effort Cost', 
                                    'Mid. Effort Cost', 
                                    'High Effort Cost')),
         new_names = sapply(names, rename_scenario),
         tamr = paste(new_names, new_AC, sep = ' '),
         new_quantile = sapply(quantile, rename_quantiles))%>%
  subset(new_quantile %in% c('10%','20%', '50%', '80%','90%'))%>%
  ggplot(aes(x = new_names, y = x, color = Stable))+
  scale_color_manual(values = c('darkblue', 'brown'))+
  geom_point(size = 2)+
  #scale_color_continuous('Estimate of unit effort cost', type = 'viridis')+
  facet_grid(new_AC~new_quantile)+
  theme_bw()+
  xlab(' ')+
  ylab(' ')+
  ggtitle("Vertical monopoly steady states with linear and linear quadratic costs")+
  theme(axis.text.x = element_text(angle = 60, 
                                   hjust = 1,
                                   family = font_), 
        axis.title.x= element_text(family = font_),
        axis.title.y = element_text(family = font_),
        plot.title = element_text(hjust = 0.5,
                                  family = font_),
        strip.text.x  = element_text(family = font_) ,
        axis.text = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))
```

```{r, Cournot}

final_dat %>%
  subset(AC>0)%>%
  subset(names %in% c('ss_cournot_lq', 'ss_cournot'))%>%
  mutate(new_AC = factor(sapply(AC, rename_W), 
                         levels = c('Low Effort Cost', 
                                    'Mid. Effort Cost', 
                                    'High Effort Cost')),
         new_names = sapply(names, rename_scenario),
         tamr = paste(new_names, new_AC, sep = ' '),
         new_quantile = sapply(quantile, rename_quantiles))%>%
  subset(new_quantile %in% c('10%','20%', '50%', '80%','90%'))%>%
  ggplot(aes(x = new_names, y = x, color = Stable))+
  scale_color_manual(values = c('darkblue', 'brown'))+
  geom_point(size = 2)+
  #scale_color_continuous('Estimate of unit effort cost', type = 'viridis')+
  facet_grid(new_AC~new_quantile)+
  theme_bw()+
  xlab(' ')+
  ylab(' ')+
  ggtitle("Quantity adjustment steady states with linear and linear quadratic costs")+
  theme(axis.text.x = element_text(angle = 60, 
                                   hjust = 1,
                                   family = font_), 
        axis.title.x= element_text(family = font_),
        axis.title.y = element_text(family = font_),
        plot.title = element_text(hjust = 0.5,
                                  family = font_),
        strip.text.x  = element_text(family = font_) ,
        axis.text = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))
```

```{r, Bertrand}
final_dat %>%
  subset(AC>0)%>%
  subset(names %in% c('ss_bertrand_lq', 'ss_bertrand'))%>%
  mutate(new_AC = factor(sapply(AC, rename_W), 
                         levels = c('Low Effort Cost', 
                                    'Mid. Effort Cost', 
                                    'High Effort Cost')),
         new_names = sapply(names, rename_scenario),
         tamr = paste(new_names, new_AC, sep = ' '),
         new_quantile = sapply(quantile, rename_quantiles))%>%
  subset(new_quantile %in% c('10%','20%', '50%', '80%','90%'))%>%
  ggplot(aes(x = new_names, y = x, color = Stable))+
  scale_color_manual(values = c('darkblue', 'brown'))+
  geom_point(size = 2)+
  #scale_color_continuous('Estimate of unit effort cost', type = 'viridis')+
  facet_grid(new_AC~new_quantile)+
  theme_bw()+
  xlab(' ')+
  ylab(' ')+
  ggtitle("Price setting steady states with linear and linear quadratic costs")+
  theme(axis.text.x = element_text(angle = 60, 
                                   hjust = 1,
                                   family = font_), 
        axis.title.x= element_text(family = font_),
        axis.title.y = element_text(family = font_),
        plot.title = element_text(hjust = 0.5,
                                  family = font_),
        strip.text.x  = element_text(family = font_) ,
        axis.text = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))


```

# Run sensitivity analysis for linear quadratic model

In this section : 

* Define the scenarios to run sensitivity analysis on: use the sensitivity table used previously and interpolate with `W_lq`

* Run all the analysis

* Identify the parameter spaces for which the targets of (i) improving stock and (ii) maintaining profitability are **met** or not

## I. Define parameter spaces

```{r, sensitivity analysis}
rm(dat_,
   store,
   result1, 
   W_lq, 
   w_pal_val_conf, 
   w_par, 
   w_par_ops, 
   w_par_val)

if(!file.exists(here('data', 'inputs', 'params_sensitivity_lq.csv'))){
  # Load original parameters for sensitivity analysis. 
  params_sensitivity = read.csv(here('data', 'inputs', 'params_sensitivity.csv'))
  # Set up names for new sensitivity analysis scenarios
  new_params_sensitivity = data.frame(matrix(nrow = 0, ncol = 15 ))
  colnames(new_params_sensitivity) = c(colnames(params_sensitivity), 'W1', 'W2', 'quantile')
  # Set each row of data as a scenario
  for(row in 1:nrow(params_sensitivity)){
    W = params_sensitivity[row, 'W']
    # Set cost that would work in quadratic case
    cost = 2*max_E*W
    # Generate costs that solve the linear quadratic cost
    W1 = quantile(seq(0, cost), probs = c(0, .2, .5, .7, 1))
    W2 = rev(quantile((cost - W1)/(2*max_E), probs = c(0, .2, .5, .7, 1)))
    # Set storage 
    to_append = data.frame(W, W1, W2)
    to_append = to_append %>% 
      mutate(quantile = rownames(to_append))%>%
      select(-W)
    rownames(to_append) = NULL
    
    # Extend existing row scenario with new data on costs
    a = cbind(params_sensitivity[rep(row, nrow(to_append)),], to_append)
    # Store
    new_params_sensitivity = rbind(new_params_sensitivity, a)
  }
  # Save data
  new_params_sensitivity = new_params_sensitivity %>%
    mutate(identifier = seq(1:nrow(new_params_sensitivity)))
  write.csv(new_params_sensitivity, here('data', 'inputs', 'params_sensitivity_lq.csv'), row.names = F)
}else{
  new_params_sensitivity = read.csv(here('data', 'inputs', 'params_sensitivity_lq.csv'))
}

print(paste0("There are ", nrow(new_params_sensitivity), " combinations" ))
```

## II. Run sensitivity analysis

```{r, sensitivity}
model_run = function(param){
  # Variable assignment
  to_assign = names(param)
  if('X' %in% to_assign){
    to_assign = to_assign[!(to_assign %in% c('X','spec', 'transformation', 'quantile', 'identifier'))]
    }
  for(variable in to_assign){
        assign(variable, 
               as.numeric(unlist(param[variable])))
    }
  # Compute secondary parameters
  alpha_w = alpha
  alpha_f = alpha
  beta_w = beta
  beta_f = beta
  # Demand functions parameters
  e   = gamma/(beta_w*beta_f - (gamma^2))
  a_f = (alpha_f*beta_w - alpha_w*gamma)/(beta_w*beta_f - (gamma^2))
  a_w = (alpha_w*beta_f - alpha_f*gamma)/(beta_w*beta_f - (gamma^2))
  b_f = beta_f/(beta_w*beta_f - (gamma^2))
  b_w = beta_w/(beta_w*beta_f - (gamma^2))
  
  W_mid = W
  # Define functions : 
  growth = function(x, 
                    k.=k, 
                    r.=r){
  y = r.*x*(1-x/k.)
  return(y)
}

# I. Price taker
  pt_harvest = function(x, 
                        alpha. = alpha, 
                        beta. = beta, 
                        W. = W_mid, 
                        c. = c, 
                        sigma. = sigma){
  y = ((alpha.-c.) * x^2 * sigma.^2)/(4*W. + beta. * sigma.^2 * x^2)
  return(y)
  }

# II. Monopoly
  monop_harvest = function(x, 
                           alpha. = alpha, 
                           c. = c, 
                           sigma. = sigma, 
                           beta. = beta, 
                           W. = W_mid){
  y = ((alpha. - c.)*sigma.^2 * x^2) / (2*beta.* sigma.^2 * x^2 + 2*W.)
  return(y)
  }

  monop_harvest_lq = function(x,
                              alpha. = alpha, 
                              c. = c, 
                              sigma. = sigma, 
                              beta. = beta,
                              W1. = W1,
                              W2. = W2){
  y = (sigma.^2 * x^2 * (alpha. - c.) - W1.*sigma.*x)/(2*(beta.*sigma.^2 * x^2 + W2.))
  return(y)
  }


# III. Cournot

  cournot_harvest = function(x, 
                             alpha_f. = alpha_f, 
                             alpha_w. = alpha_w, 
                             beta_f. = beta_f, 
                             beta_w. = beta_w, 
                             gamma. = gamma, 
                             sigma. = sigma, 
                             c. = c, 
                             v. = v, 
                             W. = W_mid){
  y = ((sigma.^2)*(x^2)*(2*beta_f.*(alpha_w. - c.) - gamma.*(alpha_f. - v.)))/(4*beta_f.*W. + (sigma.^2)*(x^2)*(4*beta_f.*beta_w. - (gamma.^2)))
  return(y)
  }

  cournot_harvest_lq = function(x, 
                                alpha_f. = alpha_f, 
                                alpha_w. = alpha_w, 
                                beta_f. = beta_f, 
                                beta_w. = beta_w, 
                                gamma. = gamma, 
                                sigma. = sigma, 
                                c. = c, 
                                v. = v, 
                                W1. = W1, 
                                W2. = W2){
  y = ((2*beta_f. * (alpha_w. - c.) - gamma. * (alpha_w. -v.))*sigma.^2 * x^2 - 2*beta_f.*W1.*sigma.*x)/(4*beta_f.*W2. + (4*beta_f.*beta_w. - gamma.^2)*sigma.^2 * x^2)
  return(y)
  }

  price_poachers_cournot = function(x,
                                    alpha_f. = alpha_f, 
                                    alpha_w. = alpha_w, 
                                    beta_f. = beta_f, 
                                    beta_w. = beta_w, 
                                    gamma. = gamma, 
                                    sigma. = sigma, 
                                    c. = c, 
                                    v. = v, 
                                    W. = W_mid){
  y = (2*W.*(2*beta_f.*(alpha_w. - c.) - gamma.*(alpha_f. - v.)))/((sigma.^2)*(x^2)*(4*beta_f.*beta_w. - gamma.^2) + 4*beta_f.*W.)
  return(y)
  }

  cournot_farmed = function(s, 
                            alpha_f. = alpha_f, 
                            alpha_w. = alpha_w, 
                            beta_f. = beta_f, 
                            beta_w. = beta_w, 
                            gamma. = gamma, 
                            sigma. = sigma, 
                            c. = c, 
                            v. = v){
  y = (2 * beta_w. * (alpha_f. - v.) - gamma.* (alpha_w. - (s + c.)) )/(4*beta_w.*beta_f. - gamma.^2)
  return(y)
  }

# IV. Bertrand

  price_poachers_bertrand = function(x, 
                                     a_f. = a_f, 
                                     a_w. = a_w, 
                                     b_f. = b_f, 
                                     b_w. = b_w, 
                                     e.  = e, 
                                     c. = c, 
                                     v. = v, 
                                     sigma. = sigma, 
                                     W. = W_mid){
  y = (2*W.*b_w.*( b_f.*(2*a_w. + e.*v.) + c.*((e.^2) - 2*b_f.*b_w.) + e.*a_f.))/((sigma.^2)*(x^2)*(4*b_f.*b_w. - (e.^2)) + 2*W.*b_w.*(2*b_w.*b_f. - (e.^2)))
  return(y)
  }

  bertrand_harvest = function(x,
                              sigma. = sigma, 
                              a_f. = a_f, 
                              a_w. = a_w, 
                              b_f. = b_f, 
                              b_w. = b_w, 
                              e. = e, 
                              v. = v, 
                              c. = c, 
                              W. = W_mid){
  y = ((sigma.^2)*(x^2)*b_w.*(b_f.*(2*a_w.+e.*v.) + c.*((e.^2)- 2*b_f.*b_w.) + e.*a_f.))/((sigma.^2)*(x^2)*(4*b_w.*b_f. - (e.^2)) + 2*W.*b_w.*(2*b_f.*b_w. - (e.^2)))
  return(y)
  }

  bertrand_harvest_lq = function(x,
                                 sigma. = sigma, 
                                 a_f. = a_f, 
                                 a_w. = a_w, 
                                 b_f. = b_f, 
                                 b_w. = b_w, 
                                 e. = e, 
                                 v. = v, 
                                 c. = c, 
                                 W1. = W1, 
                                 W2. = W2){
  y1 = b_w.*(sigma.^2 * x^2 *((2*a_w. +e.*v.)*b_f. + e.*a_f.) + (c. + W1. * sigma. * b_w. * x)*(e.^2 - 2*b_w. *b_f.))
  y2 = 2*W2.*b_w.*(2*b_f.* b_w. - e.^2) + (4*b_f.*b_w. - e.^2)*sigma.^2*x^2
  z = y1*y2
  return(z)
  }

  price_poacher_bertrand_lq = function(x,
                                       sigma. = sigma, 
                                       a_f. = a_f, 
                                       a_w. = a_w, 
                                       b_f. = b_f, 
                                       b_w. = b_w, 
                                       e. = e, 
                                       v. = v, 
                                       c. = c, 
                                       W1. = W1, 
                                       W2. = W2){
  y = 2*b_w.*W2.*((2*a_w. + e.*v.)*b_f. + e.*a_f. + c.*(e.^2 - b_f.*b_w.)) + W1.*sigma.*x*(4*b_f.*b_w. - e.^2)
  z = sigma.^2 * x^2 * (4*b_w.*b_f. - e.^2) + 4*b_w.*W2.*(2*b_f.*b_w - e.^2)
  result = y/z
  return(result)
 }

  composite_bertrand_lq = function(x,
                                   sigma. = sigma, 
                                   a_f. = a_f, 
                                   a_w. = a_w, 
                                   b_f. = b_f, 
                                   b_w. = b_w, 
                                   e. = e, 
                                   v. = v, 
                                   c. = c, 
                                   W1. = W1, 
                                   W2. = W2){
  y = b_w. * ((2*a_w. +e.*v.)*b_f. + e.*a_f. + (price_poacher_bertrand_lq(x)+c.)*(e.^2 - 2*b_w.*b_f))/(4*b_f.*b_w. - e.^2)
  return(y)
  }

  bertrand_farmed = function(s, 
                             a_f. = a_f, 
                             a_w. = a_w, 
                             b_f. = b_f, 
                             b_w. = b_w, 
                             e. = e, 
                             c. = c, 
                             v. = v){
  y = b_f. *(2*b_w.*a_f. + v.*(e.^2 - 2*b_w.*b_f.) + e.*(a_w. + (s+c.)*b_w.))/(4*b_f.*b_w. - e.^2)
  return(y)
  }
  
  # Run model 
  kolaf = data.frame(x = seq(1,k,.5 ))%>%
    mutate(growth= growth(x),
           monop_harvest = monop_harvest(x),
           monop_harvest_lq = monop_harvest_lq(x),
           cournot_harvest = cournot_harvest(x),
           cournot_harvest_lq = cournot_harvest_lq(x),
           bertrand_harvest = bertrand_harvest(x),
           bertrand_harvest_lq = composite_bertrand_lq(x),
           ss_monop = monop_harvest - growth, 
           ss_monop_lq = monop_harvest_lq - growth, 
           ss_cournot = cournot_harvest - growth, 
           ss_cournot_lq = cournot_harvest_lq - growth,
           ss_bertrand = bertrand_harvest - growth, 
           ss_bertrand_lq = bertrand_harvest_lq - growth,
           price_poachers_lq = price_poacher_bertrand_lq(x),
           price_poachers_bertrand = price_poachers_bertrand(x)) 
  #Identify steady states  
  errr= kolaf %>%
    pivot_longer(-x, 
                 names_to = 'names', 
                 values_to = 'values')%>%
    subset(names %in% c('ss_monop',
                        'ss_monop_lq',
                        'ss_cournot',
                        'ss_cournot_lq',
                        'ss_bertrand',
                        'ss_bertrand_lq'))%>%
    subset(values > -.1)%>%
    subset(values < .1)
 
  keep_row = data.frame(matrix(nrow = 0, ncol = 4))
  colnames(keep_row)= c('x', 'names', "values", 'lag_sign')

  for(name in unique(errr$names)){
    study = errr %>%
      subset(names == name)%>%
      mutate(lag_sign = c(0, diff(sign(values))), # Mutate to get sign change and value of steady state change
             lag_val = c(0, diff(x)))
    # Define cut vector to scan through each zone : cuts are defined as jumps in x value 
      cuts_ = which(study$lag_val>5 | study$lag_val < -5) - 1
      cuts_ = c(0,cuts_, nrow(study))
    # Use cuts vector to scan through
      keep = data.frame(matrix(nrow = 0, ncol = 4))
      colnames(keep) = c('x', 'names', "values", 'lag_sign')

    for(cut in 1:(length(cuts_)-1)){
      lb_ = cuts_[cut]+1
      ub_ = cuts_[cut+1]
    
      to_check = study[lb_: ub_,]%>%
        subset(lag_sign !=0)%>%
        subset(lag_val>0)%>% # Keep only when the lag value is positive : otherwise, it means a change in sequence or type of equilibrium
        select(-c(lag_val))
      
      keep = rbind(keep, to_check)
    }
  keep_row = rbind(keep_row, keep)
  }
  # Store
  keep_row = keep_row %>%
    mutate(row_ =unlist(param['identifier']))
 return(keep_row)
}

if(!file.exists(here('data', 'outputs', 'sensitivity_analysis_lq', 'steady_states.csv'))){
  # Set up cores
  numcores = detectCores() - 4
    # Make clusters
  cl = makeCluster(numcores)
    # Load tidyverse : otherwise, pipe operator is not recognized
  clusterEvalQ(cl,  library(tidyverse))
    # Start timer
  start = Sys.time()
    # Apply function accross nodes with a slice of the data of lenght width
  storage = parApply(cl, 
                    new_params_sensitivity,
                    1,
                    model_run)
  print(paste0('Process took : ', Sys.time() - start, ' minutes with ', numcores, ' processors'))

  storage = bind_rows(storage)
  write.csv(storage, here('data', 'outputs','sensitivity_analysis_lq', 'steady_states.csv'), row.names = F)

}else{
  storage = read.csv(here('data', 'outputs','sensitivity_analysis_lq', 'steady_states.csv'))
}
```

## II. Exploit data

* Define a baseline scenario : in this case, take $W$ as our main specification, and the midpoint for $W_1$ and $W_2$

* Compute the difference in steady state

* Somehow illustrate it

```{r, sensitivity results}
new_params_sensitivity = new_params_sensitivity%>%
  rename(row_ = identifier)
storage = storage %>%
  mutate(row_ = as.numeric(row_))

exploit_ = merge(storage, new_params_sensitivity, by = 'row_')%>%
  distinct()%>%
  mutate(row_ = as.numeric(row_))

if('X.1' %in% colnames(exploit_)){
  exploit_ = exploit_ %>%
    select(- X.1)
}


normalizer = exploit_ %>%
  subset(spec == 'baseline')%>%
  subset(quantile == '50%')%>%
  subset(names == 'ss_monop')%>%
  select(x)%>%
  pull()

exploit_ = exploit_%>%
  mutate(normalized_ss = (x-normalizer)/normalizer*100)
```

```{r, illustration}
v_color = function(x){
  if(x %in% c(paste(unique(exploit_$v), -2))){
    return('Unstable')
  }else{
    return(strsplit(x, ' ')[[1]][1])
  }
}

palette = c(brewer.pal(8, 'Blues'), paste0('grey',seq(50,90, by = 5)))

check = exploit_ %>%
  #subset(quantile %in% c('50%'))%>%
  subset(spec == 'v')%>%
  subset(names != 'ss_monop')%>%
  mutate(quantile = as.factor(quantile),
         names = as.factor(names), 
         v_stab = paste(round(v,1), 
                        lag_sign))
to_lev = c(unique(round(check$v,1)),
           paste(unique(round(check$v,1)), -2))

check$v_stab = factor(check$v_stab)
levels(check$v_stab) = to_lev

check%>%
  ggplot(aes(x = names, 
           y= normalized_ss, 
           color = as.factor(v),
           shape = as.factor(lag_sign)))+
  geom_point(position = position_dodge(.8), size = 3)+
  scale_color_manual(values = palette)+
  scale_shape_manual(values= c(4, 19))+
  facet_grid(~W1)+
  scale_x_discrete()+
  theme_minimal()

# Here : 
# - Make v_stab2 a factor and make the values fall in relevant order
# - Color scale with length()/2 +1 (with last one in gray)
# - Change the labels in the legend
# - Use guide legend (override.aes) with alpha = 0 for length/2-1 last values

```


```{r, bizarre}


```
### IV. Include profitability

In this section : 

* Define profit functions 

* Check the profit at steady state levels

* Compare with baseline scenario

```{r, define profitability}

profit = function(param){
  # Variable assignement
  to_assign = names(param)
  
  
  if('row_' %in% to_assign){
    to_assign = to_assign[!(to_assign %in% c('X','spec', 'transformation', 'quantile', 'normalized_ss'))]
    }
  for(variable in to_assign){
    if(variable == 'names'){
      assign(variable,
             unlist(param[variable]))
    }else{
        assign(variable, 
               as.numeric(unlist(param[variable])))
    }
  }
  
  alpha_w = alpha
  alpha_f = alpha
  beta_w = beta
  beta_f = beta
  # Demand functions parameters
  e   = gamma/(beta_w*beta_f - (gamma^2))
  a_f = (alpha_f*beta_w - alpha_w*gamma)/(beta_w*beta_f - (gamma^2))
  a_w = (alpha_w*beta_f - alpha_f*gamma)/(beta_w*beta_f - (gamma^2))
  b_f = beta_f/(beta_w*beta_f - (gamma^2))
  b_w = beta_w/(beta_w*beta_f - (gamma^2))
  
  W_mid = W
  
  if(names == 'ss_monop'){
    # Redefine harvest
    monop_harvest = function(x, 
                             alpha. = alpha, 
                             c. = c, 
                             sigma. = sigma, 
                             beta. = beta, 
                             W. = W_mid){
    y = ((alpha. - c.)*sigma.^2 * x^2) / (2*beta.* sigma.^2 * x^2 + 2*W.)
    return(y)
    }
    # Define outputs : 
      # Poached harvest
    poached_harvest = monop_harvest(x)
      # Farmed harvest : 
    farmed_harvest = NA
    # Prices paid:
    price_poachers = (alpha_w - c)*W/(beta*sigma^2*x^2+W)
    # Profits:
      # Profit from poaching
    profit_poaching = (alpha - beta * poached_harvest - c - price_poachers)*poached_harvest
      # Profit from farming
    profit_farming = NA
    profit_fishermen = (price_poachers*sigma*x)^2/(4*W)
    
  }else if(names == 'ss_monop_lq'){
    # Redefine harvest
    monop_harvest_lq = function(x,
                                alpha. = alpha, 
                                c. = c, 
                                sigma. = sigma, 
                                beta. = beta,
                                W1. = W1,
                                W2. = W2){
    y = (sigma.^2 * x^2 * (alpha. - c.) - W1.*sigma.*x)/(2*(beta.*sigma.^2 * x^2 + W2.))
    return(y)
    }
    # Harvest:
    poached_harvest = monop_harvest_lq(x)
    farmed_harvest = NA
    # Price : 
    price_poachers = (W2*(alpha-c)+beta*W1*sigma*x)/(beta*sigma^2*x^2 + W2)
    # Redefine profit
    profit_poaching = (alpha - beta*poached_harvest - c - price_poachers)*poached_harvest
    profit_fishermen = price_poachers * poached_harvest - W1*((price_poachers * sigma * x -W1)/(2*W2)) - W2*((price_poachers * sigma * x - W1)/(2*W2))^2
    profit_farming = NA
  }else if(names == 'ss_cournot'){
    # Redefine harvests and price paid to poachers
    cournot_harvest = function(x, 
                               alpha_f. = alpha_f, 
                               alpha_w. = alpha_w, 
                               beta_f. = beta_f, 
                               beta_w. = beta_w, 
                               gamma. = gamma, 
                               sigma. = sigma, 
                               c. = c, 
                               v. = v, 
                               W. = W_mid){
        y = ((sigma.^2)*(x^2)*(2*beta_f.*(alpha_w. - c.) - gamma.*(alpha_f. - v.)))/(4*beta_f.*W. + (sigma.^2)*(x^2)*(4*beta_f.*beta_w. - (gamma.^2)))
        return(y)
      }
    
    price_poachers_cournot = function(x,
                                      alpha_f. = alpha_f, 
                                      alpha_w. = alpha_w, 
                                      beta_f. = beta_f, 
                                      beta_w. = beta_w, 
                                      gamma. = gamma, 
                                      sigma. = sigma, 
                                      c. = c, 
                                      v. = v, 
                                      W. = W_mid){
    y = (2*W.*(2*beta_f.*(alpha_w. - c.) - gamma.*(alpha_f. - v.)))/((sigma.^2)*(x^2)*(4*beta_f.*beta_w. - gamma.^2) + 4*beta_f.*W.)
    return(y)
    }

    cournot_farmed = function(s, 
                              alpha_f. = alpha_f, 
                              alpha_w. = alpha_w, 
                              beta_f. = beta_f, 
                              beta_w. = beta_w, 
                              gamma. = gamma, 
                              sigma. = sigma, 
                              c. = c, 
                              v. = v){
    y = (2 * beta_w. * (alpha_f. - v.) - gamma.* (alpha_w. - (s + c.)) )/(4*beta_w.*beta_f. - gamma.^2)
    return(y)
    }
    
    # Results  
    poached_harvest = cournot_harvest(x)
    price_poachers = price_poachers_cournot(x)
    farmed_harvest = cournot_farmed(price_poachers)
      
    profit_poaching = (alpha_w - beta_w * poached_harvest - gamma * farmed_harvest - c - price_poachers)*poached_harvest
    profit_farming  = (alpha_f - beta_f * farmed_harvest - gamma * poached_harvest -c - v) * farmed_harvest
    profit_fishermen = (price_poachers*x*sigma)^2/(4*W)
    
  }else if(names == 'ss_cournot_lq'){
    cournot_harvest_lq = function(x, 
                                  alpha_f. = alpha_f, 
                                  alpha_w. = alpha_w, 
                                  beta_f. = beta_f, 
                                  beta_w. = beta_w, 
                                  gamma. = gamma, 
                                  sigma. = sigma, 
                                  c. = c, 
                                  v. = v, 
                                  W1. = W1, 
                                  W2. = W2){
    y = ((2*beta_f. * (alpha_w. - c.) - gamma. * (alpha_w. -v.))*sigma.^2 * x^2 - 2*beta_f.*W1.*sigma.*x)/(4*beta_f.*W2. + (4*beta_f.*beta_w. - gamma.^2)*sigma.^2 * x^2)
    return(y)
    }
    
    poached_harvest = cournot_harvest_lq(x)
    price_poachers = (2*W2*(2*beta_f*(alpha_w - c) - gamma*(alpha_f - v)) + W1*sigma*x*(4*beta_f*beta_w - gamma^2))/(4*beta_f*W2 + (4*beta_f*beta_w - gamma^2)*sigma^2*x^2)
    farmed_harvest = (2*beta_w*(alpha_f - v) - gamma*(alpha_w - price_poachers - c))/(4*beta_w*beta_f - gamma^2)
    
    profit_poaching = (alpha_w - beta_w * poached_harvest - gamma * farmed_harvest - price_poachers - c)*poached_harvest
    profit_farming = (alpha_f - beta_f * farmed_harvest - gamma * poached_harvest - v)* farmed_harvest
    profit_fishermen = price_poachers * poached_harvest - W1*((price_poachers * sigma * x -W1)/(2*W2)) - W2*((price_poachers * sigma * x - W1)/(2*W2))^2
    
  }else if(names == 'ss_bertrand'){
    
    price_poachers_bertrand = function(x, 
                                       a_f. = a_f, 
                                       a_w. = a_w, 
                                       b_f. = b_f, 
                                       b_w. = b_w, 
                                       e.  = e, 
                                       c. = c, 
                                       v. = v, 
                                       sigma. = sigma, 
                                       W. = W_mid){
    y = (2*W.*b_w.*( b_f.*(2*a_w. + e.*v.) + c.*((e.^2) - 2*b_f.*b_w.) + e.*a_f.))/((sigma.^2)*(x^2)*(4*b_f.*b_w. - (e.^2)) + 2*W.*b_w.*(2*b_w.*b_f. - (e.^2)))
    return(y)
    }

    bertrand_harvest = function(x,
                                sigma. = sigma, 
                                a_f. = a_f, 
                                a_w. = a_w, 
                                b_f. = b_f, 
                                b_w. = b_w, 
                                e. = e, 
                                v. = v, 
                                c. = c, 
                                W. = W_mid){
    y = ((sigma.^2)*(x^2)*b_w.*(b_f.*(2*a_w.+e.*v.) + c.*((e.^2)- 2*b_f.*b_w.) + e.*a_f.))/((sigma.^2)*(x^2)*(4*b_w.*b_f. - (e.^2)) + 2*W.*b_w.*(2*b_f.*b_w. - (e.^2)))
    return(y)
    }
    bertrand_farmed = function(s, 
                               a_f. = a_f, 
                               a_w. = a_w, 
                               b_f. = b_f, 
                               b_w. = b_w, 
                               e. = e, 
                               c. = c, 
                               v. = v){
    y = b_f. *(2*b_w.*a_f. + v.*(e.^2 - 2*b_w.*b_f.) + e.*(a_w. + (s+c.)*b_w.))/(4*b_f.*b_w. - e.^2)
    return(y)
    }
    
    poached_harvest = bertrand_harvest(x)
    price_poachers = price_poachers_bertrand(x)
    farmed_harvest = bertrand_farmed(price_poachers)

    profit_fishermen = (price_poachers*x*sigma)^2/(4*W)
    profit_poaching = (alpha_w - beta_w * poached_harvest - gamma * farmed_harvest - c - price_poachers) * poached_harvest
    profit_farming = (alpha_f - beta_f * farmed_harvest - gamma * poached_harvest - v)*farmed_harvest
    
  }else if(names == 'ss_bertrand_lq'){
    price_poacher_bertrand_lq = function(x,
                                         sigma. = sigma, 
                                         a_f. = a_f, 
                                         a_w. = a_w, 
                                         b_f. = b_f, 
                                         b_w. = b_w, 
                                         e. = e, 
                                         v. = v, 
                                         c. = c, 
                                         W1. = W1, 
                                         W2. = W2){
    y = 2*b_w.*W2.*((2*a_w. + e.*v.)*b_f. + e.*a_f. + c.*(e.^2 - b_f.*b_w.)) + W1.*sigma.*x*(4*b_f.*b_w. - e.^2)
    z = sigma.^2 * x^2 * (4*b_w.*b_f. - e.^2) + 4*b_w.*W2.*(2*b_f.*b_w - e.^2)
    result = y/z
    return(result)
    }

    composite_bertrand_lq = function(x,
                                     sigma. = sigma, 
                                     a_f. = a_f, 
                                     a_w. = a_w, 
                                     b_f. = b_f, 
                                     b_w. = b_w, 
                                     e. = e, 
                                     v. = v, 
                                     c. = c, 
                                     W1. = W1, 
                                     W2. = W2){
    y = b_w. * ((2*a_w. +e.*v.)*b_f. + e.*a_f. + (price_poacher_bertrand_lq(x)+c.)*(e.^2 - 2*b_w.*b_f))/(4*b_f.*b_w. - e.^2)
    return(y)
    }
    
    price_poachers = price_poacher_bertrand_lq(x)
    poached_harvest = composite_bertrand_lq(price_poachers)
    farmed_harvest = b_f*(b_w*(2*a_f + e*(price_poachers + c)) + e*a_w + v*(e^2 - 2*b_w*b_f))/(4*b_f*b_w - e^2)
    
    profit_poaching = (alpha_w - beta_w * poached_harvest + gamma*farmed_harvest - price_poachers - c)*poached_harvest
    profit_farming = (alpha_f - beta_f * farmed_harvest + gamma * poached_harvest -v)*farmed_harvest
    profit_fishermen = price_poachers * poached_harvest - W1*((price_poachers * sigma * x -W1)/(2*W2)) - W2*((price_poachers * sigma * x - W1)/(2*W2))^2
  }
  
  result = data.frame(row_, names, poached_harvest, farmed_harvest, price_poachers, profit_poaching, profit_farming, profit_fishermen, lag_sign)
  rownames(result) = NULL
  #result = t(as.data.frame(result))
  colnames(result) = c('row_', 'name','poached_harvest', 'farmed_harvest', 'price_poachers', 'profit_poaching', 'profit_farming', 'profit_fishermen','stability')
  return(result)
}
 
profit(exploit_[4,])
if(!file.exists(here('data', 'outputs', 'sensitivity_analysis_lq', 'profitability.csv'))){
  # Set up cores
  numcores = detectCores() - 4
    # Make clusters
  cl = makeCluster(numcores)
    # Load tidyverse : otherwise, pipe operator is not recognized
  clusterEvalQ(cl,  library(tidyverse))
    # Start timer
  start = Sys.time()
    # Apply function accross nodes with a slice of the data of lenght width
  storage = parApply(cl, 
                    exploit_,
                    1,
                    profit)
  print(paste0('Process took : ', Sys.time() - start, ' minutes with ', numcores, ' processors'))

  storage = bind_rows(storage)
  write.csv(storage, here('data', 'outputs','sensitivity_analysis_lq', 'profitability.csv'), row.names = F)

}else{
  storage = read.csv(here('data', 'outputs','sensitivity_analysis_lq', 'profitability.csv'))
}

```

With profitability done, in the following I :

1. Compute the aggregate profit : **DONE**

2. Compute the cost of policy : based on our baseline estimates, I use the difference with values in the sensitivity analysis, where this is to be taken as a **scenario analysis** instead. I get the per unit cost of policies (subsidies and transaction costs for the traders) - *need to match with existing data and do the computation of unit cost*

3. Compute the variation for each profit and policy costs, along each scenario

```{r, profitability computation}

storage[is.na(storage)] = 0
storage_stable = storage %>%
  subset(stability > 0)%>% # only consider stable equilibria
  mutate(ag_profit = profit_poaching + profit_farming + profit_fishermen)

# Normalize
baseline_profit_monop = storage %>%
  subset(name == 'ss_monop')%>%
  subset(row_ == 1)%>%
  select(profit_poaching)%>%
  pull()

baseline_profit_fishermen = storage %>%
  subset(name == 'ss_monop')%>%
  subset(row_ == 1)%>%
  select(profit_fishermen)%>%
  pull()

baseline_profit_farming = storage %>%
  subset(name == 'ss_monop')%>%
  subset(row_ == 1)%>%
  select(profit_farming)%>%
  pull()

baseline_ag_profit = storage_stable %>%
  subset(row_ == 1)%>%
  subset(name == 'ss_monop')%>%
  select(ag_profit)%>%
  pull()

# Issue with Pi_farming = 0 in baseline scenario
#storage_stable = storage_stable%>%
#  mutate(ag_profit_rate = (ag_profit - baseline_ag_profit)/ baseline_ag_profit,
#         profit_poaching_rate = (profit_poaching - baseline_profit_monop)/baseline_profit_monop,
#         profit_fishermen_rate = (profit_fishermen) )

# Go with absolute variation : 
storage_stable = storage_stable %>%
  mutate(ag_profit_diff = ag_profit - baseline_ag_profit, 
         profit_farming_diff = profit_farming - baseline_profit_farming, 
         profit_poaching_diff = profit_farming_diff - baseline_profit_monop,
         profit_fishermen_diff = profit_fishermen - baseline_profit_fishermen)
```
# To do

* Re-run sensitivity analysis and make sure the saving of the data is right : **DONE**

* Finalize the `profit(...)` function and architecture: take the steady-state value only : **DONE**

* Think of ways to visualize both outputs e.g. the population stock and the profitability. 

# Annexes : debugging
```{r, dev}

```



