---
title: "3b_Sensitivity_analysis"
author: "Simon Jean"
date: "2024-04-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
options(scipen=999)

library(tidyverse)
library(scales)
library(colorspace)
library("ggsci")
library(here)
library(knitr)
library(stargazer)
library(parallel)
library(wesanderson)

rm(list = ls())
```


# Sensitivity analysis 

## A. Load data
```{r, meta parameters}
# Styling
font_ = 'Helvetica'
pal = c('#fde725', 'black','#7ad151', '#22a884', '#2a788e', '#414487','#440154', 'grey')

```

```{r, data import}
# Data load
calibration = read.csv(here('data', 'outputs', 'calibration_params.csv'))
v_par = read.csv(here("data", 'inputs', "v_par.csv")) 
W_lq = read.csv(here("data", 'inputs', 'W_lq_new.csv'))
``` 


## B. Set up parameter space

Redo parameter for sensitivity analysis : 

```{r, range of analysis}
# Assignation of baseline parameters
for(i in 1:nrow(calibration)){
  assign(calibration$params[i], calibration$value[i])
}

baseline = data.frame(beta = beta, 
                      alpha = alpha, 
                      gamma = gamma, 
                      W = W_high, 
                      W1 = W1, 
                      W2 = W2,
                      c = c,
                      v = v,
                      r = r, 
                      k = k,
                      interest_rate = i_r,
                      sigma = sigma,
                      spec = 'baseline', 
                      transformation = 1)

params_sensitivity = baseline

# II. Define all the parameter values we want to test: ####

## 1. Single parameters

### A. Sensitivity to cost parameters

#### i. Quadratic model : 

w_sens = c(0.5,.7, 1, 1.3, 1.5)
sensitivity= do.call(rbind, replicate(length(w_sens), baseline, simplify = FALSE))%>%
  mutate(W1 = 0, 
         W2 = W*w_sens, 
         spec = 'W - quadratic', 
         transformation = w_sens)
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)
#### ii. Linear quadratic model

sensitivity= do.call(rbind, replicate(nrow(W_lq), baseline, simplify = FALSE))%>%
  mutate(W1 = W_lq$W1,
         W2 = W_lq$W2, 
         spec = 'W1 and W2')
sensitivity['transformation'] = paste(W_lq$W1/W1, ' and ', W_lq$W2/W2)

params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)
### B. Substitutability
gamma_sens = c(.01, .1, .2, .5, .75, .8, .9, .99)

sensitivity= do.call(rbind, replicate(length(gamma_sens), baseline, simplify = F))%>%
  mutate(gamma = beta*sqrt(gamma_sens),
         spec = 'gamma',
         transformation = gamma_sens)
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)

### C. Trading costs
c_sens = c(0, 2,  5, 8, 10, 15, 20, 50)
c_plus = 100
sensitivity = do.call(rbind, replicate(length(c_sens), baseline, simplify = F))%>%
  mutate(c = (c+c_plus)*c_sens,
         spec = 'c',
         transformation = paste(c_plus, ' + ', c_sens))
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)
### D. Demand intercept

alpha_sens = c(.5, .6, .8, 1,1.2, 1.4, 1.6, 1.8, 2)

sensitivity = do.call(rbind, replicate(length(alpha_sens), baseline, simplify = F))%>%
  mutate(alpha = alpha*alpha_sens,
         spec = 'alpha',
         transformation = alpha_sens)
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)

### E. Demand sensitivity
beta_sens = c(.5, .8, 1.2, 1.5, 1.8, 2, NA, NA)

sensitivity = do.call(rbind, replicate(length(beta_sens), baseline, simplify = F))%>%
  mutate(beta = beta*beta_sens,
         spec = 'beta',
         transformation = beta_sens)
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)



### F. Interest rate
i_sens = c(.05, .07, .1, .15, .2)

v_ = v_par %>% 
  select(op_cost_per_t)%>%
  pull()
age = 4.5

v_sens = c()
for(i in i_sens){
 v = v_*age
 v_cap = v_*(1 + (1 + i) + (1 + i)^2 + (1 + i)^3 + (1+ i)^3.5)
 v_sens = append(v_sens, v_cap)
}

sensitivity = do.call(rbind, replicate(length(v_sens), baseline, simplify = F))%>%
  mutate(v = v_sens,
         interest_rate = i_sens,
         spec = 'interest',
         transformation = i_sens)
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)

params_sensitivity = params_sensitivity %>%
  drop_na()
## 2. Joint Parameters
### A. c and v

c_sens_ = c_plus * c_sens
to_append = expand.grid(v_sens,
                        c_sens_)

sensitivity = do.call(rbind, replicate(nrow(to_append), baseline, simplify = F))%>%
  mutate(v = to_append$Var1,
         c = to_append$Var2,
         spec = 'v and c',
         transformation = paste('c=',round((to_append$Var1 - c_plus)/c_sens,2),'and v=',round(to_append$Var2/v_sens,2)))
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)
### B. c and v and gamma
gamma_sens_ = beta*sqrt(gamma_sens)
to_append = expand.grid(v_sens, 
                        c_sens_, 
                        gamma_sens_)
sensitivity = do.call(rbind, replicate(nrow(to_append), baseline, simplify = F))%>%
  mutate(v = to_append$Var1,
         c = to_append$Var2,
         gamma = to_append$Var3,
         spec = 'v and c and gamma',
         transformation = paste('c=',round((to_append$Var1 - c_plus)/c_sens,2),'and v=',round(to_append$Var2/v_sens,2), 'and gamma', to_append$Var3/gamma_sens))
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)

### C. alpha and gamma
alpha_sens_ = alpha*alpha_sens

to_append = expand.grid(alpha_sens_,
                        gamma_sens_)
sensitivity = do.call(rbind, replicate(nrow(to_append), baseline, simplify = F))%>%
  mutate(alpha = to_append$Var1,
         gamma = to_append$Var2,
         spec = 'alpha and gamma',
         transformation = paste('alpha=',(to_append$Var1/alpha_sens),'and gamma=', (to_append$Var2/gamma_sens)))
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)
# Set an identifier
params_sensitivity = params_sensitivity %>%
  mutate(identifier = seq(1, nrow(params_sensitivity)))

rm(sensitivity, to_append)
```


## C. Run model 

Define model run, and yield `exploit_` a dataset with parameters and corresponding steady states. 

```{r, model run}

model_run = function(params){
  to_assign = names(params)

  for(variable in to_assign){
    if(is.character(variable)){
      assign(variable,
             unlist(params[variable]))
    }else{
        assign(variable, 
               as.numeric(unlist(params[variable])))
    }
  }
  
  # Define functions for model run 
  alpha_w = alpha
  alpha_f = alpha
  beta_w = beta
  beta_f = beta
  # Demand functions parameters
  e   = gamma/(beta_w*beta_f - (gamma^2))
  a_f = (alpha_f*beta_w - alpha_w*gamma)/(beta_w*beta_f - (gamma^2))
  a_w = (alpha_w*beta_f - alpha_f*gamma)/(beta_w*beta_f - (gamma^2))
  b_f = beta_f/(beta_w*beta_f - (gamma^2))
  b_w = beta_w/(beta_w*beta_f - (gamma^2))
  
  growth = function(x, 
                  k.=k, 
                  r.=r){
  y = r.*x*(1-x/k.)
  return(y)
}

  # I. Monopoly
  monop_harvest_lq = function(x,
                              alpha. = alpha, 
                              c. = c, 
                              sigma. = sigma, 
                              beta. = beta,
                              W1. = W1,
                              W2. = W2){
    y = (sigma.^2 * x^2 * (alpha. - c.) - W1.*sigma.*x)/(2*(beta.*sigma.^2 * x^2 + W2.))
    return(y)
  }


  # II. Cournot
  cournot_harvest_lq = function(x, 
                                alpha_f. = alpha_f, 
                                alpha_w. = alpha_w, 
                                beta_f. = beta_f, 
                                beta_w. = beta_w, 
                                gamma. = gamma, 
                                sigma. = sigma, 
                                c. = c, 
                                v. = v, 
                                W1. = W1, 
                                W2. = W2){
    y = ((2*beta_f. * (alpha_w. - c.) - gamma. * (alpha_w. -v.))*sigma.^2 * x^2 - 2*beta_f.*W1.*sigma.*x)/(4*beta_f.*W2. + (4*beta_f.*beta_w. - gamma.^2)*sigma.^2 * x^2)
    return(y)
  }
  
  price_poachers_cournot_lq = function(x,
                                       alpha_f. = alpha_f, 
                                       alpha_w. = alpha_w, 
                                       beta_f. = beta_f, 
                                       beta_w. = beta_w, 
                                       gamma. = gamma, 
                                       sigma. = sigma, 
                                       c. = c, 
                                       v. = v, 
                                       W1. = W1, 
                                       W2. = W2){
    y = (2*W2.*(2*beta_f.*(alpha_w. - c) - gamma.*(alpha_f. - v.)) + W1.*sigma.*x*(4*beta_f.*beta_w. - gamma.^2))/(4*beta_f.*W2. + (4*beta_f.*beta_w. - gamma.^2)*sigma.^2*x^2)
    return(y)
  }
  
  farmed_cournot_lq = function(price_poachers,
                               alpha_f. = alpha_f, 
                               alpha_w. = alpha_w, 
                               beta_f. = beta_f, 
                               beta_w. = beta_w, 
                               gamma. = gamma, 
                               sigma. = sigma, 
                               c. = c, 
                               v. = v, 
                               W1. = W1, 
                               W2. = W2){
    y = (2*beta_w.*(alpha_f. - v.) - gamma.*(alpha_w. - price_poachers - c.))/(4*beta_w.*beta_f. - gamma.^2)
    return(y)
  }

  # III. Bertrand

  bertrand_harvest_lq = function(x,
                                 sigma. = sigma, 
                                 a_f. = a_f, 
                                 a_w. = a_w, 
                                 b_f. = b_f, 
                                 b_w. = b_w, 
                                 e. = e, 
                                 v. = v, 
                                 c. = c, 
                                 W1. = W1, 
                                 W2. = W2){
    y1 = b_w.*(sigma.^2 * x^2 *((2*a_w. +e.*v.)*b_f. + e.*a_f.) + (c. + W1. * sigma. * b_w. * x)*(e.^2 - 2*b_w. *b_f.))
    y2 = 2*W2.*b_w.*(2*b_f.* b_w. - e.^2) + (4*b_f.*b_w. - e.^2)*sigma.^2*x^2
    z = y1/y2
    return(z)
  }

  price_poacher_bertrand_lq = function(x,
                                       sigma. = sigma, 
                                       a_f. = a_f, 
                                       a_w. = a_w, 
                                       b_f. = b_f, 
                                       b_w. = b_w, 
                                       e. = e, 
                                       v. = v, 
                                       c. = c, 
                                       W1. = W1, 
                                       W2. = W2){
    y = 2*b_w.*W2.*((2*a_w. + e.*v.)*b_f. + e.*a_f. + c.*(e.^2 - b_f.*b_w.)) + W1.*sigma.*x*(4*b_f.*b_w. - e.^2)
    z = sigma.^2 * x^2 * (4*b_w.*b_f. - e.^2) + 4*b_w.*W2.*(2*b_f.*b_w - e.^2)
    result = y/z
    return(result)
  }

  composite_bertrand_lq = function(x,
                                   sigma. = sigma, 
                                   a_f. = a_f, 
                                   a_w. = a_w, 
                                   b_f. = b_f, 
                                   b_w. = b_w, 
                                   e. = e, 
                                   v. = v, 
                                   c. = c, 
                                   W1. = W1, 
                                   W2. = W2){
    y = b_w. * ((2*a_w. +e.*v.)*b_f. + e.*a_f. + (price_poacher_bertrand_lq(x)+c.)*(e.^2 - 2*b_w.*b_f))/(4*b_f.*b_w. - e.^2)
    return(y)
  }

  bertrand_farmed = function(s,
                             a_f. = a_f, 
                             a_w. = a_w, 
                             b_f. = b_f, 
                             b_w. = b_w, 
                             e. = e, 
                             c. = c, 
                             v. = v){
    y = b_f. *(2*b_w.*a_f. + v.*(e.^2 - 2*b_w.*b_f.) + e.*(a_w. + (s+c.)*b_w.))/(4*b_f.*b_w. - e.^2)
    return(y)
  }
  
  # Run model :
  result1 = data.frame(x = seq(1,k,.5 ))%>%
    mutate(growth= growth(x),
           # Harvests with quadratic and linear-quadratic costs
           monop_harvest_lq = monop_harvest_lq(x),
           cournot_harvest_lq = cournot_harvest_lq(x),
           #bertrand_harvest_lq = bertrand_harvest_lq(x),
           bertrand_harvest_lq = composite_bertrand_lq(x),
           # Prices
           price_poachers_bertrand = price_poacher_bertrand_lq(x),
           price_poachers_cournot = price_poachers_cournot_lq(x),
           # Farmed
           bertrand_farmed_lq = bertrand_farmed(price_poachers_bertrand),
           cournot_farmed_lq = farmed_cournot_lq(price_poachers_cournot),
           # Steady states
           ss_monop_lq = monop_harvest_lq - growth, 
           ss_cournot_lq = cournot_harvest_lq - growth,
           ss_bertrand_lq = bertrand_harvest_lq - growth
           )

  # Put data in long format and keep only values close to the steady state
  errr = result1 %>% 
    pivot_longer(-x, names_to = 'names', values_to = 'values')%>%
    subset(names %in% c('ss_monop_lq',
                        'ss_cournot_lq',
                        'ss_bertrand_lq'))%>%
    subset(values > -.2)%>%
    subset(values < .2)
  
  # Initiate storage
  final_dat = data.frame(0, 0, 0, 0)
  colnames(final_dat) = c(colnames(errr), 'lag_sign')

  
  # Loop over each scenario to identify one steady state
  for(name in unique(errr$names)){
    study = errr %>%
      subset(names == name)%>%
      mutate(lag_sign = c(0, diff(sign(values))), # Mutate to get sign change and value of steady state change
             lag_val = c(0, diff(x)))
    # Define cut vector to scan through each zone : cuts are defined as jumps in x value 
    cuts_ = which(study$lag_val>5 | study$lag_val < -5) - 1
    cuts_ = c(0,cuts_, nrow(study))
    # Use cuts vector to scan through
    for(cut in 1:(length(cuts_)-1)){
      lb_ = cuts_[cut]+1
      ub_ = cuts_[cut+1]
    
      to_check = study[lb_: ub_,]%>%
        subset(lag_sign !=0)%>%
        subset(lag_val>0)%>% # Keep only when the lag value is positive : otherwise, it means a change in sequence or type of equilibrium
        select(-c(lag_val))
    
      final_dat = rbind(final_dat, to_check)
    }
  }
  
  final_dat = final_dat %>%
    mutate(Stable = ifelse(lag_sign>0,'Stable', 'Unstable'))%>%
    subset(x>0)
  #%>%
  #  subset(lag_sign >0)
  return(final_dat)
  }
storage = data.frame(0,0,0,0,0,0)
colnames(storage) = c('x', 'names', 'values', 'lag_sign', 'Stable', 'identifier')
for(row in 1:nrow(params_sensitivity)){
  storage =rbind(storage,
                 model_run(params_sensitivity[row,])%>%
                   mutate(identifier = row))
}
# Keep only real data
storage = storage %>%
  subset(identifier >0)

# Merge with parameters
exploit_ = left_join(storage, params_sensitivity, by = 'identifier')%>%
  distinct()%>%
  mutate(identifier = as.numeric(identifier))
# Might have to pivot longer to match with previous codes and graphs; 
```

Check the occurence of steady states : 
```{r, steady state coarse}
# Analyse if multiple steady states have been recorded for various scenarios
checker = data.frame(table(exploit_$identifier))

# Rename the variables
exploit_ = exploit_ %>%
  group_by(identifier, names)%>%
  mutate(id_2 = row_number(),
         names_2 = paste0(names,id_2))%>%
  ungroup() %>%
  relocate(names_2, .after = names)%>%
  relocate(identifier,.after = x)%>%
  relocate(x, .after = names_2)

```


## D. Analysis

### 1. Impact of variation of cost paramets


### 2. Impact of joint variation of demand parameters

```{r, demand}
# Set up baselines
baseline_gamma = calibration %>%
  subset(params == 'gamma')%>%
  select(value)%>%
  pull()

baseline_alpha = calibration%>%
  subset(params == 'alpha')%>%
  select(value)%>%
  pull()

baseline_beta = calibration %>%
  subset(params == 'beta')%>%
  select(value)%>%
  pull()

baseline_alpha = calibration %>%
  subset(params == 'alpha')%>%
  select(value)%>%
  pull()

baseline_stock = exploit_ %>%
  subset(spec == 'baseline')%>%
  subset(names == 'ss_monop_lq')%>%
  select(x)%>%
  pull()

# Set up data 
graph_dat = exploit_ %>%
  subset(spec %in% c('alpha and gamma'))%>%
  subset(alpha > .6*baseline_alpha)%>%
  subset(!(names %in% c('ss_monop_lq')))%>%
  mutate(alpha = as.factor(alpha/baseline_alpha))%>%
  
  subset(gamma %in% c(sqrt(.1) * baseline_beta, sqrt(.5)* baseline_beta, 
                      sqrt(.75)* baseline_beta, sqrt(.9)* baseline_beta))%>%
  mutate(alpha2 = as.factor(paste(alpha, Stable)),
         gamma2 = round(gamma,2),
         value2 = (x - baseline_stock)/baseline_stock*100)


work = strsplit(levels(graph_dat$alpha2), ' ')
new_levs = c()
for(k in 1:length(work)){
  to_check = work[[k]]
  if(to_check[2] =="Stable"){
    new_levs = append(new_levs, as.character((as.numeric(to_check[1]) - 1)*100))
  }else{
    new_levs = append(new_levs, 'Unstable')
  }
}
levels(graph_dat$alpha2) = new_levs

# Graph
graph_dat %>%
  ggplot(aes(x = names, 
             y = value2, 
             colour = alpha2))+
  geom_point(size = 2.5)+
  facet_grid(~gamma2)+
  scale_color_manual(values = pal,
                     breaks = c("-20", "0", "20", "40", "60","80", "100"))+
  theme_bw()+
  #geom_hline(yintercept = -43, linetype = 'dotted')+
  #geom_hline(yintercept = -86, linetype = 'dotted')+
  geom_hline(yintercept = 0, linetype = 'dashed', color = 'grey')+
  xlab(' ')+
  ylab('Deviation (in %) from vertical \nmonopoly equilibrium population')+
  scale_shape_manual(values = c(4, 17, 8))+
  labs(colour = 'Demand \nvariation (in %)')+
  guides(shape = 'none',
         color=guide_legend(nrow=4, byrow=F))+
theme(axis.text.x = element_text(angle = 60,
                                   hjust = 1),
        legend.position = "right",
        strip.text.x  = element_text(family = font_) ,
        axis.title.x  = element_text(family = font_),
        axis.text = element_text(family = font_),
        axis.title.y  = element_text(family = font_, size = 9),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_), 
        aspect.ratio = 10/4)

```

That sucks : with new specification, quantity adjustment can go wrong when demand increases by 80% in the baseline scenario... That changes our recommendations. 


