---
title: "3b_Sensitivity_analysis"
author: "Simon Jean"
date: "2024-04-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
options(scipen=999)

library(tidyverse)
library(scales)
library(colorspace)
library("ggsci")
library(here)
library(knitr)
library(stargazer)
library(parallel)
library(wesanderson)

rm(list = ls())
```


# Sensitivity analysis 

## A. Load data
```{r, meta parameters}
# Styling
font_ = 'Helvetica'
pal = c('#fde725', 'black','#7ad151', '#22a884', '#2a788e', '#414487','#440154', 'grey')

```

```{r, data import}
# Data load
calibration = read.csv(here('data', 'outputs', 'calibration_params.csv'))
v_par = read.csv(here("data", 'inputs', "v_par.csv")) 
W_lq = read.csv(here("data", 'inputs', 'W_lq_new.csv'))
``` 


## B. Set up parameter space

Redo parameter for sensitivity analysis : 

```{r, range of analysis}
# Assignation of baseline parameters
for(i in 1:nrow(calibration)){
  assign(calibration$params[i], calibration$value[i])
}

baseline = data.frame(beta = beta, 
                      alpha = alpha, 
                      gamma = gamma, 
                      W = W_high, 
                      W1 = W1, 
                      W2 = W2,
                      c = c,
                      v = v,
                      r = r, 
                      k = k,
                      interest_rate = i_r,
                      sigma = sigma,
                      spec = 'baseline', 
                      transformation = 1)

params_sensitivity = baseline

# II. Define all the parameter values we want to test: ####

## 1. Single parameters

### A. Sensitivity to cost parameters

#### i. Quadratic model : 

w_sens = c(0.5,.7, 1, 1.3, 1.5)
sensitivity= do.call(rbind, replicate(length(w_sens), baseline, simplify = FALSE))%>%
  mutate(W1 = 0, 
         W2 = W*w_sens, 
         spec = 'W - quadratic', 
         transformation = w_sens)
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)
#### ii. Linear quadratic model

W_lq_append = W_lq
W_lq_append = W_lq_append%>%
  mutate(W1 = 1.1 * W1)

W_lq = rbind(W_lq, W_lq_append)

sensitivity= do.call(rbind, replicate(nrow(W_lq), baseline, simplify = FALSE))%>%
  mutate(W1 = W_lq$W1,
         W2 = W_lq$W2, 
         spec = 'W1 and W2')
sensitivity['transformation'] = paste(1, "and", W_lq$W1/W1, ' and ', W_lq$W2/W2)

params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)
max_E = 1920

for(m in c(.9, 1.1, 1.2, 1.3)){

  sensitivity= do.call(rbind, replicate(nrow(W_lq), baseline, simplify = FALSE))%>%
    mutate(W1 = seq(avg_cost*m-3000, avg_cost*m, length.out = nrow(sensitivity)))%>%
    mutate(W2 = (avg_cost*m-W1)/(2*max_E),
           spec = 'W1 and W2')
  sensitivity['transformation'] = paste(m, 'and', W_lq$W1/W1, ' and ', W_lq$W2/W2)

  params_sensitivity = rbind(params_sensitivity, 
                            sensitivity)
}
### B. Substitutability
gamma_sens = c(.01, .1, .2,.3, .4, .5, .6, .7,.75, .8, .9, .99)
sensitivity= do.call(rbind, replicate(length(gamma_sens), baseline, simplify = F))%>%
  mutate(gamma = beta*sqrt(gamma_sens),
         spec = 'gamma',
         transformation = gamma_sens)
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)


### C. Trading costs
c_sens = seq(0,300, by = 5)
c_plus = 100
sensitivity = do.call(rbind, replicate(length(c_sens), baseline, simplify = F))%>%
  mutate(c = (c+c_plus)*c_sens,
         spec = 'c',
         transformation = paste(c_plus, ' + ', c_sens))
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)
### D. Demand intercept

alpha_sens = c(.5, .6, .8, 1,1.2, 1.4, 1.6, 1.8, 2)

sensitivity = do.call(rbind, replicate(length(alpha_sens), baseline, simplify = F))%>%
  mutate(alpha = alpha*alpha_sens,
         spec = 'alpha',
         transformation = alpha_sens)
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)

### E. Demand sensitivity
beta_sens = c(.5, .8, 1.2, 1.5, 1.8, 2, NA, NA)

sensitivity = do.call(rbind, replicate(length(beta_sens), baseline, simplify = F))%>%
  mutate(beta = beta*beta_sens,
         spec = 'beta',
         transformation = beta_sens)
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)



### F. Interest rate
i_sens = c(.05, .07, .1, .15, .2)

v_ = v_par %>% 
  select(op_cost_per_t)%>%
  pull()
age = 4.5

v_sens = c()
for(i in i_sens){
 v = v_*age
 v_cap = v_*(1 + (1 + i) + (1 + i)^2 + (1 + i)^3 + (1+ i)^3.5)
 v_sens = append(v_sens, v_cap)
}

sensitivity = do.call(rbind, replicate(length(v_sens), baseline, simplify = F))%>%
  mutate(v = v_sens,
         interest_rate = i_sens,
         spec = 'interest',
         transformation = i_sens)
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)

params_sensitivity = params_sensitivity %>%
  drop_na()

### G. Subsidy on aquaculture 
v = baseline$v
v_sens = v* seq(.5,1.1, by = 0.04)

sensitivity = do.call(rbind, replicate(length(v_sens), baseline, simplify = F))%>%
  mutate(v = v_sens,
         spec = 'subsidy',
         transformation = seq(.5,1.1, by = 0.04))
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)


## 2. Joint Parameters
### A. c and v

c_sens_ = c_plus * c_sens
to_append = expand.grid(v_sens,
                        c_sens_)

sensitivity = do.call(rbind, replicate(nrow(to_append), baseline, simplify = F))%>%
  mutate(v = to_append$Var1,
         c = to_append$Var2,
         spec = 'v and c',
         transformation = paste('c=',round((to_append$Var1 - c_plus)/c_sens,2),'and v=',round(to_append$Var2/v_sens,2)))
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)
### B. c and v and gamma
gamma_sens_ = beta*sqrt(gamma_sens)
to_append = expand.grid(v_sens, 
                        c_sens_, 
                        gamma_sens_)
sensitivity = do.call(rbind, replicate(nrow(to_append), baseline, simplify = F))%>%
  mutate(v = to_append$Var1,
         c = to_append$Var2,
         gamma = to_append$Var3,
         spec = 'v and c and gamma',
         transformation = paste('c=',round((to_append$Var1 - c_plus)/c_sens,2),'and v=',round(to_append$Var2/v_sens,2), 'and gamma', to_append$Var3/gamma_sens))
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)

### C. alpha and gamma
alpha_sens_ = alpha*alpha_sens

to_append = expand.grid(alpha_sens_,
                        gamma_sens_)
sensitivity = do.call(rbind, replicate(nrow(to_append), baseline, simplify = F))%>%
  mutate(alpha = to_append$Var1,
         gamma = to_append$Var2,
         spec = 'alpha and gamma',
         transformation = paste('alpha=',(to_append$Var1/alpha_sens),'and gamma=', (to_append$Var2/gamma_sens)))
params_sensitivity = rbind(params_sensitivity, 
                           sensitivity)
# Set an identifier
params_sensitivity = params_sensitivity %>%
  mutate(identifier = seq(1, nrow(params_sensitivity)))

rm(sensitivity, to_append)
```


## C. Run model 

Define model run, and yield `exploit_` a dataset with parameters and corresponding steady states. 

```{r, model run}

model_run = function(params){
  to_assign = names(params)

  for(variable in to_assign){
    if(is.character(variable)){
      assign(variable,
             unlist(params[variable]))
    }else{
        assign(variable, 
               as.numeric(unlist(params[variable])))
    }
  }
  
  # Define functions for model run 
  alpha_w = alpha
  alpha_f = alpha
  beta_w = beta
  beta_f = beta
  # Demand functions parameters
  e   = gamma/(beta_w*beta_f - (gamma^2))
  a_f = (alpha_f*beta_w - alpha_w*gamma)/(beta_w*beta_f - (gamma^2))
  a_w = (alpha_w*beta_f - alpha_f*gamma)/(beta_w*beta_f - (gamma^2))
  b_f = beta_f/(beta_w*beta_f - (gamma^2))
  b_w = beta_w/(beta_w*beta_f - (gamma^2))
  
  growth = function(x, 
                  k.=k, 
                  r.=r){
  y = r.*x*(1-x/k.)
  return(y)
}

  # I. Monopoly
  monop_harvest_lq = function(x,
                              alpha. = alpha, 
                              c. = c, 
                              sigma. = sigma, 
                              beta. = beta,
                              W1. = W1,
                              W2. = W2){
    y = (sigma.^2 * x^2 * (alpha. - c.) - W1.*sigma.*x)/(2*(beta.*sigma.^2 * x^2 + W2.))
    return(y)
  }


  # II. Cournot
  cournot_harvest_lq = function(x, 
                                alpha_f. = alpha_f, 
                                alpha_w. = alpha_w, 
                                beta_f. = beta_f, 
                                beta_w. = beta_w, 
                                gamma. = gamma, 
                                sigma. = sigma, 
                                c. = c, 
                                v. = v, 
                                W1. = W1, 
                                W2. = W2){
    y = ((2*beta_f. * (alpha_w. - c.) - gamma. * (alpha_w. -v.))*sigma.^2 * x^2 - 2*beta_f.*W1.*sigma.*x)/(4*beta_f.*W2. + (4*beta_f.*beta_w. - gamma.^2)*sigma.^2 * x^2)
    return(y)
  }
  
  price_poachers_cournot_lq = function(x,
                                       alpha_f. = alpha_f, 
                                       alpha_w. = alpha_w, 
                                       beta_f. = beta_f, 
                                       beta_w. = beta_w, 
                                       gamma. = gamma, 
                                       sigma. = sigma, 
                                       c. = c, 
                                       v. = v, 
                                       W1. = W1, 
                                       W2. = W2){
    y = (2*W2.*(2*beta_f.*(alpha_w. - c) - gamma.*(alpha_f. - v.)) + W1.*sigma.*x*(4*beta_f.*beta_w. - gamma.^2))/(4*beta_f.*W2. + (4*beta_f.*beta_w. - gamma.^2)*sigma.^2*x^2)
    return(y)
  }
  
  farmed_cournot_lq = function(price_poachers,
                               alpha_f. = alpha_f, 
                               alpha_w. = alpha_w, 
                               beta_f. = beta_f, 
                               beta_w. = beta_w, 
                               gamma. = gamma, 
                               sigma. = sigma, 
                               c. = c, 
                               v. = v, 
                               W1. = W1, 
                               W2. = W2){
    y = (2*beta_w.*(alpha_f. - v.) - gamma.*(alpha_w. - price_poachers - c.))/(4*beta_w.*beta_f. - gamma.^2)
    return(y)
  }

  # III. Bertrand

  bertrand_harvest_lq = function(x,
                                 sigma. = sigma, 
                                 a_f. = a_f, 
                                 a_w. = a_w, 
                                 b_f. = b_f, 
                                 b_w. = b_w, 
                                 e. = e, 
                                 v. = v, 
                                 c. = c, 
                                 W1. = W1, 
                                 W2. = W2){
    y1 = b_w.*(sigma.^2 * x^2 *((2*a_w. +e.*v.)*b_f. + e.*a_f.) + (c. + W1. * sigma. * b_w. * x)*(e.^2 - 2*b_w. *b_f.))
    y2 = 2*W2.*b_w.*(2*b_f.* b_w. - e.^2) + (4*b_f.*b_w. - e.^2)*sigma.^2*x^2
    z = y1/y2
    return(z)
  }

  price_poacher_bertrand_lq = function(x,
                                     sigma. = sigma, 
                                     a_f. = a_f, 
                                     a_w. = a_w, 
                                     b_f. = b_f, 
                                     b_w. = b_w, 
                                     e. = e, 
                                     v. = v, 
                                     c. = c, 
                                     W1. = W1, 
                                     W2. = W2){
  y = 2*b_w.*W2.*((2*a_w. + e.*v.)*b_f. + e.*a_f. + c.*(e.^2 - 2* b_f.*b_w.)) + W1.*sigma.*x*(4*b_f.*b_w. - e.^2)
  z = sigma.^2 * x^2 * (4*b_w.*b_f. - e.^2) + 2*b_w.*W2.*(2*b_f.*b_w - e.^2)
  result = y/z
  return(result)
}

  composite_bertrand_lq = function(x,
                                   sigma. = sigma, 
                                   a_f. = a_f, 
                                   a_w. = a_w, 
                                   b_f. = b_f, 
                                   b_w. = b_w, 
                                   e. = e, 
                                   v. = v, 
                                   c. = c, 
                                   W1. = W1, 
                                   W2. = W2){
    y = b_w. * ((2*a_w. +e.*v.)*b_f. + e.*a_f. + (price_poacher_bertrand_lq(x)+c.)*(e.^2 - 2*b_w.*b_f))/(4*b_f.*b_w. - e.^2)
    return(y)
  }

  bertrand_farmed = function(s,
                             a_f. = a_f, 
                             a_w. = a_w, 
                             b_f. = b_f, 
                             b_w. = b_w, 
                             e. = e, 
                             c. = c, 
                             v. = v){
    y = b_f. *(2*b_w.*a_f. + v.*(e.^2 - 2*b_w.*b_f.) + e.*(a_w. + (s+c.)*b_w.))/(4*b_f.*b_w. - e.^2)
    return(y)
  }
  
  # Run model :
  result1 = data.frame(x = seq(1,k,.5 ))%>%
    mutate(growth= growth(x),
           # Harvests with quadratic and linear-quadratic costs
           monop_harvest_lq = monop_harvest_lq(x),
           cournot_harvest_lq = cournot_harvest_lq(x),
           #bertrand_harvest_lq = bertrand_harvest_lq(x),
           bertrand_harvest_lq = composite_bertrand_lq(x),
           # Prices
           price_poachers_bertrand = price_poacher_bertrand_lq(x),
           price_poachers_cournot = price_poachers_cournot_lq(x),
           # Farmed
           bertrand_farmed_lq = bertrand_farmed(price_poachers_bertrand),
           cournot_farmed_lq = farmed_cournot_lq(price_poachers_cournot),
           # Steady states
           ss_monop_lq = monop_harvest_lq - growth, 
           ss_cournot_lq = cournot_harvest_lq - growth,
           ss_bertrand_lq = bertrand_harvest_lq - growth
           )

  # Put data in long format and keep only values close to the steady state
  errr = result1 %>% 
    pivot_longer(-x, names_to = 'names', values_to = 'values')%>%
    subset(names %in% c('ss_monop_lq',
                        'ss_cournot_lq',
                        'ss_bertrand_lq'))%>%
    subset(values > -.2)%>%
    subset(values < .2)
  
  # Initiate storage
  final_dat = data.frame(0, 0, 0, 0)
  colnames(final_dat) = c(colnames(errr), 'lag_sign')

  
  # Loop over each scenario to identify one steady state
  for(name in unique(errr$names)){
    study = errr %>%
      subset(names == name)%>%
      mutate(lag_sign = c(0, diff(sign(values))), # Mutate to get sign change and value of steady state change
             lag_val = c(0, diff(x)))
    # Define cut vector to scan through each zone : cuts are defined as jumps in x value 
    cuts_ = which(study$lag_val>5 | study$lag_val < -5) - 1
    cuts_ = c(0,cuts_, nrow(study))
    # Use cuts vector to scan through
    for(cut in 1:(length(cuts_)-1)){
      lb_ = cuts_[cut]+1
      ub_ = cuts_[cut+1]
    
      to_check = study[lb_: ub_,]%>%
        subset(lag_sign !=0)%>%
        subset(lag_val>0)%>% # Keep only when the lag value is positive : otherwise, it means a change in sequence or type of equilibrium
        select(-c(lag_val))
    
      final_dat = rbind(final_dat, to_check)
    }
  }
  
  final_dat = final_dat %>%
    mutate(Stable = ifelse(lag_sign>0,'Stable', 'Unstable'))%>%
    subset(x>0)%>%
    mutate(row = identifier)
  #%>%
  #  subset(lag_sign >0)
  return(final_dat)
}

model_run_par = function(params){
  params = suppressWarnings(as.numeric(unlist(params, use.names = T)))
  beta  = params[1]
  alpha = params[2]
  gamma = params[3]
  W     = params[4]
  W1    = params[5]
  W2    = params[6]
  c     = params[7]
  v     = params[8]
  r     = params[9]
  k     = params[10]
  interest_rate = params[11]
  sigma = params[12]
  identifier = params[15]
  
  # Define functions for model run 
  alpha_w = alpha
  alpha_f = alpha
  beta_w = beta
  beta_f = beta
  # Demand functions parameters
  e   = gamma/(beta_w*beta_f - (gamma^2))
  a_f = (alpha_f*beta_w - alpha_w*gamma)/(beta_w*beta_f - (gamma^2))
  a_w = (alpha_w*beta_f - alpha_f*gamma)/(beta_w*beta_f - (gamma^2))
  b_f = beta_f/(beta_w*beta_f - (gamma^2))
  b_w = beta_w/(beta_w*beta_f - (gamma^2))
  
  growth = function(x, 
                  k.=k, 
                  r.=r){
  y = r.*x*(1-x/k.)
  return(y)
}

  # I. Monopoly
  monop_harvest_lq = function(x,
                              alpha. = alpha, 
                              c. = c, 
                              sigma. = sigma, 
                              beta. = beta,
                              W1. = W1,
                              W2. = W2){
    y = (sigma.^2 * x^2 * (alpha. - c.) - W1.*sigma.*x)/(2*(beta.*sigma.^2 * x^2 + W2.))
    return(y)
  }


  # II. Cournot
  cournot_harvest_lq = function(x, 
                                alpha_f. = alpha_f, 
                                alpha_w. = alpha_w, 
                                beta_f. = beta_f, 
                                beta_w. = beta_w, 
                                gamma. = gamma, 
                                sigma. = sigma, 
                                c. = c, 
                                v. = v, 
                                W1. = W1, 
                                W2. = W2){
    y = ((2*beta_f. * (alpha_w. - c.) - gamma. * (alpha_w. -v.))*sigma.^2 * x^2 - 2*beta_f.*W1.*sigma.*x)/(4*beta_f.*W2. + (4*beta_f.*beta_w. - gamma.^2)*sigma.^2 * x^2)
    return(y)
  }
  
  price_poachers_cournot_lq = function(x,
                                       alpha_f. = alpha_f, 
                                       alpha_w. = alpha_w, 
                                       beta_f. = beta_f, 
                                       beta_w. = beta_w, 
                                       gamma. = gamma, 
                                       sigma. = sigma, 
                                       c. = c, 
                                       v. = v, 
                                       W1. = W1, 
                                       W2. = W2){
    y = (2*W2.*(2*beta_f.*(alpha_w. - c) - gamma.*(alpha_f. - v.)) + W1.*sigma.*x*(4*beta_f.*beta_w. - gamma.^2))/(4*beta_f.*W2. + (4*beta_f.*beta_w. - gamma.^2)*sigma.^2*x^2)
    return(y)
  }
  
  farmed_cournot_lq = function(price_poachers,
                               alpha_f. = alpha_f, 
                               alpha_w. = alpha_w, 
                               beta_f. = beta_f, 
                               beta_w. = beta_w, 
                               gamma. = gamma, 
                               sigma. = sigma, 
                               c. = c, 
                               v. = v, 
                               W1. = W1, 
                               W2. = W2){
    y = (2*beta_w.*(alpha_f. - v.) - gamma.*(alpha_w. - price_poachers - c.))/(4*beta_w.*beta_f. - gamma.^2)
    return(y)
  }

  # III. Bertrand

  bertrand_harvest_lq = function(x,
                                 sigma. = sigma, 
                                 a_f. = a_f, 
                                 a_w. = a_w, 
                                 b_f. = b_f, 
                                 b_w. = b_w, 
                                 e. = e, 
                                 v. = v, 
                                 c. = c, 
                                 W1. = W1, 
                                 W2. = W2){
    y1 = b_w.*(sigma.^2 * x^2 *((2*a_w. +e.*v.)*b_f. + e.*a_f.) + (c. + W1. * sigma. * b_w. * x)*(e.^2 - 2*b_w. *b_f.))
    y2 = 2*W2.*b_w.*(2*b_f.* b_w. - e.^2) + (4*b_f.*b_w. - e.^2)*sigma.^2*x^2
    z = y1/y2
    return(z)
  }

  price_poacher_bertrand_lq = function(x,
                                     sigma. = sigma, 
                                     a_f. = a_f, 
                                     a_w. = a_w, 
                                     b_f. = b_f, 
                                     b_w. = b_w, 
                                     e. = e, 
                                     v. = v, 
                                     c. = c, 
                                     W1. = W1, 
                                     W2. = W2){
  y = 2*b_w.*W2.*((2*a_w. + e.*v.)*b_f. + e.*a_f. + c.*(e.^2 - 2* b_f.*b_w.)) + W1.*sigma.*x*(4*b_f.*b_w. - e.^2)
  z = sigma.^2 * x^2 * (4*b_w.*b_f. - e.^2) + 2*b_w.*W2.*(2*b_f.*b_w - e.^2)
  result = y/z
  return(result)
}

  composite_bertrand_lq = function(x,
                                   sigma. = sigma, 
                                   a_f. = a_f, 
                                   a_w. = a_w, 
                                   b_f. = b_f, 
                                   b_w. = b_w, 
                                   e. = e, 
                                   v. = v, 
                                   c. = c, 
                                   W1. = W1, 
                                   W2. = W2){
    y = b_w. * ((2*a_w. +e.*v.)*b_f. + e.*a_f. + (price_poacher_bertrand_lq(x)+c.)*(e.^2 - 2*b_w.*b_f))/(4*b_f.*b_w. - e.^2)
    return(y)
  }

  bertrand_farmed = function(s,
                             a_f. = a_f, 
                             a_w. = a_w, 
                             b_f. = b_f, 
                             b_w. = b_w, 
                             e. = e, 
                             c. = c, 
                             v. = v){
    y = b_f. *(2*b_w.*a_f. + v.*(e.^2 - 2*b_w.*b_f.) + e.*(a_w. + (s+c.)*b_w.))/(4*b_f.*b_w. - e.^2)
    return(y)
  }
  
  # Run model :
  result1 = data.frame(x = seq(1,k,.5 ))%>%
    mutate(growth= growth(x),
           # Harvests with quadratic and linear-quadratic costs
           monop_harvest_lq = monop_harvest_lq(x),
           cournot_harvest_lq = cournot_harvest_lq(x),
           #bertrand_harvest_lq = bertrand_harvest_lq(x),
           bertrand_harvest_lq = composite_bertrand_lq(x),
           # Prices
           price_poachers_bertrand = price_poacher_bertrand_lq(x),
           price_poachers_cournot = price_poachers_cournot_lq(x),
           # Farmed
           bertrand_farmed_lq = bertrand_farmed(price_poachers_bertrand),
           cournot_farmed_lq = farmed_cournot_lq(price_poachers_cournot),
           # Steady states
           ss_monop_lq = monop_harvest_lq - growth, 
           ss_cournot_lq = cournot_harvest_lq - growth,
           ss_bertrand_lq = bertrand_harvest_lq - growth
           )

  # Put data in long format and keep only values close to the steady state
  errr = result1 %>% 
    pivot_longer(-x, names_to = 'names', values_to = 'values')%>%
    subset(names %in% c('ss_monop_lq',
                        'ss_cournot_lq',
                        'ss_bertrand_lq'))%>%
    subset(values > -.2)%>%
    subset(values < .2)
  
  # Initiate storage
  final_dat = data.frame(0, 0, 0, 0)
  colnames(final_dat) = c(colnames(errr), 'lag_sign')

  
  # Loop over each scenario to identify one steady state
  for(name in unique(errr$names)){
    study = errr %>%
      subset(names == name)%>%
      mutate(lag_sign = c(0, diff(sign(values))), # Mutate to get sign change and value of steady state change
             lag_val = c(0, diff(x)))
    # Define cut vector to scan through each zone : cuts are defined as jumps in x value 
    cuts_ = which(study$lag_val>5 | study$lag_val < -5) - 1
    cuts_ = c(0,cuts_, nrow(study))
    # Use cuts vector to scan through
    for(cut in 1:(length(cuts_)-1)){
      lb_ = cuts_[cut]+1
      ub_ = cuts_[cut+1]
    
      to_check = study[lb_: ub_,]%>%
        subset(lag_sign !=0)%>%
        subset(lag_val>0)%>% # Keep only when the lag value is positive : otherwise, it means a change in sequence or type of equilibrium
        select(-c(lag_val))
    
      final_dat = rbind(final_dat, to_check)
    }
  }
  
  final_dat = final_dat %>%
    mutate(Stable = ifelse(lag_sign>0,'Stable', 'Unstable'))%>%
    subset(x>0)%>%
    mutate(row = identifier)
  #%>%
  #  subset(lag_sign >0)
  return(final_dat)
}



if(!(file.exists(here('data','outputs','sensitivity_analysis.csv')))){
  
  storage = data.frame(0,0,0,0,0,0)
  colnames(storage) = c('x', 'names', 'values', 'lag_sign', 'Stable', 'identifier')
  
  if(nrow(params_sensitivity) > 10000){
    
    numcores = detectCores() - 4
    cl = makeCluster(numcores)
    # Load tidyverse : otherwise, pipe operator is not recognized
    clusterEvalQ(cl,  library(tidyverse))

    # Start timer
    start = Sys.time()
    # Apply function accross nodes with a slice of the data of lenght width
    a = parApply(cl, 
                 params_sensitivity,
                 1,
                 model_run_par)
    print(Sys.time() - start)
    stopCluster(cl)
    
    # Unlist all that 
    start = Sys.time()
    storage = 
      Reduce(function(dtf1, dtf2) rbind(dtf1, dtf2), a)
    print(Sys.time() - start)
    
    storage = storage %>%
      mutate(identifier = row)%>%
      select(-row)
  }else{
    for(row in 1:nrow(params_sensitivity)){
      storage =rbind(storage,
                   model_run(params_sensitivity[row,])%>%
                   mutate(identifier = row))
      storage = storage %>%
                   subset(identifier >0)
    }
# Keep only real data
  }

# Merge with parameters
    exploit_ = left_join(storage, params_sensitivity, by = 'identifier')%>%
      distinct()%>%
      mutate(identifier = as.numeric(identifier))

  
  write.csv(exploit_, here('data', 'outputs', 'sensitivity_analysis.csv'))
}else(
  exploit_ = read.csv(here('data', 'outputs', 'sensitivity_analysis.csv'))
)

```

Check the occurrence of steady states : 
```{r, steady state coarse}
# Analyse if multiple steady states have been recorded for various scenarios
checker = data.frame(table(exploit_$identifier))

# Rename the variables
exploit_ = exploit_ %>%
  group_by(identifier, names)%>%
  mutate(id_2 = row_number(),
         names_2 = paste0(names,id_2))%>%
  ungroup() %>%
  relocate(names_2, .after = names)%>%
  relocate(identifier,.after = x)%>%
  relocate(x, .after = names_2)

```


## D. Analysis

### 1. Impact of variation of cost parameters in fishermen profit
```{r, costs}

cost_sens = exploit_ %>%
  subset(spec == 'W1 and W2')

cost_sens = cost_sens %>%
  mutate(multiplier_global = NA, 
         W1_multiplier = NA, 
         W2_multiplier = NA)

for(row_ in 1:nrow(cost_sens)){
  a = cost_sens[row_, ]%>%
    select(transformation)%>%
    pull()
  b = strsplit(a, 'and')
  cost_sens[row_,'multiplier_global'] = b[[1]][1]
  cost_sens[row_, 'W1_multiplier'] = b[[1]][2]
  cost_sens[row_, 'W2_multiplier'] = b[[1]][3]
}

# First analysis : we keep the split e.g W1 and W2 respect the same properties, we have uncertainty around aggregate
# cost
baseline_stock = exploit_ %>%
  subset(spec == 'baseline')%>%
  subset(names == 'ss_monop_lq')%>%
  select(x)%>%
  pull()

renamer = function(x){
  if(x == 'ss_bertrand_lq'){
    return('Price setting')
  }else if(x == 'ss_cournot_lq'){
    return('Quantity adjustment')
  }else if(x == 'ss_monop_lq'){
    return("Vertical monopoly")
  }
}

cost_sens$names = sapply(cost_sens$names, renamer)

cost_sens_estimate_cost = cost_sens %>%
  mutate(W1_multiplier = as.numeric(W1_multiplier),
         W2_multiplier = as.numeric(W2_multiplier),
         x_norm = ((x-baseline_stock)/baseline_stock)*100,
         multiplier_global = paste((as.numeric(multiplier_global) - 1)*100, '%'))%>%
  filter(W1_multiplier == 1 & W2_multiplier == 1)

cost_sens_estimate_cost%>%
  ggplot(aes(x = multiplier_global, y =x_norm, color = names))+
  geom_point(size = 2.5, position = position_dodge2(width = .2))+
  scale_color_manual(values = c('#B22222','#1f78b4', '#248721'))+
  ylab("Variation from baseline steady state population")+
  xlab(' ')+
  labs(color = ' ')+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 60,
                                   hjust = 1),
        legend.position = "right",
        strip.text.x  = element_text(family = font_) ,
        axis.title.x  = element_text(family = font_),
        axis.text = element_text(family = font_),
        axis.title.y  = element_text(family = font_, size = 9),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))

ggsave(here('visuals', 'supplementary_visuals', 'uncertainty_W.jpg'))


```

```{r, table of results}
cost_sens %>%
  mutate(W1_multiplier = as.numeric(W1_multiplier),
         W2_multiplier = as.numeric(W2_multiplier),
         x_norm = ((x-baseline_stock)/baseline_stock)*100,
         multiplier_global = paste((as.numeric(multiplier_global) - 1)*100, '%'))%>%
  filter(W1_multiplier == 1 & W2_multiplier == 1)%>%
  select(c(names, x, x_norm,multiplier_global))%>%
  kable()

```
Need a subsidy rate of 20% to avoid poaching increase, eg need $v=$ `r baseline$v*0.8`
  
  
```{r, across Ws}
# Second analysis : keep the initial cost, but switch the W1 and W2 analysis
cost_sens %>%
  mutate(multiplier_global = as.numeric(multiplier_global),
         W1_multiplier = as.numeric(W1_multiplier),
         W2_multiplier = as.numeric(W2_multiplier),
         namer = paste(round(W1,1), " and ", round(W2,2)),
         baseline = as.factor(ifelse(W1_multiplier ==1 & W2_multiplier == 1, 1, 0)),
         x_norm = (x - baseline_stock)/baseline_stock*100)%>%
  filter(multiplier_global == 1)%>%
  ggplot(aes(x = namer, y =x_norm, color = names, shape = Stable, group = names))+
  geom_point(size = 2.5, position = position_dodge2(width = .2))+
  scale_color_manual(values = c('#B22222','#1f78b4', '#248721'))+
  #geom_rect(aes(fill = baseline), xmin = -Inf,xmax = Inf,
  #          ymin = -Inf,ymax = Inf,alpha = 0.1)+
  #scale_fill_manual(values = c('white', 'grey'))+
  #facet_grid(~names)+
  ylab("Variation from baseline steady state population (in %)")+
  xlab(' ')+
  theme_bw()+
  labs(color = ' ', 
       shape = ' ')+
  theme(axis.text.x = element_text(angle = 60,
                                   hjust = 1),
        legend.position = "right",
        strip.text.x  = element_text(family = font_) ,
        axis.title.x  = element_text(family = font_),
        axis.text = element_text(family = font_),
        axis.title.y  = element_text(family = font_, size = 9),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))

# Plot at the same time the various costs:
ggsave(here('visuals', 'supplementary_visuals', 'linear_or_quadratic.jpg'))

```

```{r, table of results lin quad}
cost_sens %>%
  mutate(multiplier_global = as.numeric(multiplier_global),
         W1_multiplier = as.numeric(W1_multiplier),
         W2_multiplier = as.numeric(W2_multiplier),
         namer = paste(round(W1,2), " and ", round(W2,2)),
         baseline = as.factor(ifelse(W1_multiplier ==1 & W2_multiplier == 1, 1, 0)),
         x_norm = (x - baseline_stock)/baseline_stock*100)%>%
  filter(multiplier_global == 1)%>%
  select(c(names, x, x_norm,namer))%>%
  kable()

```

### 2. Effect of v

```{r, effect of v}
v_sens = exploit_%>%
  subset(spec == 'subsidy')

v_sens$names = sapply(v_sens$names, renamer)

v_sens %>%
  mutate(transformation = (1 - as.numeric(transformation))*100,
         x_norm = (x - baseline_stock)/baseline_stock * 100)%>%
  ggplot(aes( x = transformation, y = x_norm, color = names))+
  geom_point(size = 2.5)+
  scale_color_manual(values = c('#B22222','#1f78b4', '#248721'))+
  ylab('Variation from baseline steady state population')+
  xlab('Ad-valorem subsidy rate')+
  theme_bw()+
  labs(color = ' ', 
       shape = '')+
  theme(axis.text.x = element_text(angle = 60,
                                   hjust = 1),
        legend.position = "right",
        strip.text.x  = element_text(family = font_) ,
        axis.title.x  = element_text(family = font_, size = 9),
        axis.text = element_text(family = font_),
        axis.title.y  = element_text(family = font_, size = 9),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))
ggsave(here('visuals', 'supplementary_visuals', 'effect_of_subsidy.jpg'))

```
```{r, identify v to have safe space}
v_sens %>%
  mutate(transformation = (1 - as.numeric(transformation))*100,
         x_norm = (x - baseline_stock)/baseline_stock * 100)%>%
  subset(names == 'Price setting')%>%
  subset(x_norm>=0 & x_norm < .2 )

```

### 3. Impact of different v and c

```{r, c and v}
c_and_v = exploit_ %>%
  subset(spec == 'v and c')

c_and_v$names = sapply(c_and_v$names, renamer)

c_and_v = c_and_v %>%
  mutate(x_norm = (x - baseline_stock)/baseline_stock * 100)




a = c_and_v %>%
  subset(c %in% c(0,5000, 10000, 15000, 20000, 25000, 30000))%>%
  mutate(c = as.factor(c))

store = data.frame(0,0,0,0)
colnames(store) = c('names', 'values', 'c', 'v')

names_ = c('Price setting', 'Quantity adjustment')
for(row_ in unique(a$identifier)){
  here = a %>%
    subset(identifier == row_)
  monop = here %>%
    subset(names =='Vertical monopoly')%>%
    select(x)%>%
    pull()
  bertrand = here %>%
    subset(names == 'Price setting')%>%
    select(x)%>%
    pull()
  cournot = here %>%
    subset(names == 'Quantity adjustment')%>%
    select(x)%>%
    pull()
  values = c((bertrand-monop)/monop*100, (cournot - monop)/monop*100)
  dat__ = data.frame(names_, values, 
                     rep(here%>%select(c)%>%pull()%>%unique(),2), rep(here%>%select(v)%>%pull()%>%unique(),2))
  colnames(dat__) = c('names', 'values', 'c', 'v')
  store = rbind(store, dat__)
}

baselines_ = exploit_ %>%
  subset(spec == 'baseline')
baseline_cournot = (baselines_ %>% 
  subset(names == 'ss_cournot_lq')%>%
  select(x)%>%
  pull()-baseline_stock)/baseline_stock*100
baseline_bertrand = (baselines_ %>% 
  subset(names == 'ss_bertrand_lq')%>%
  select(x)%>%
  pull()-baseline_stock)/baseline_stock*100

points = data.frame(names = c('Price setting', 'Quantity adjustment'), 
                    values = c(baseline_bertrand, baseline_cournot), 
                    v = rep(baselines_%>%select(v)%>%pull()%>%unique()))

store %>%
  subset(names != 0)%>%
  mutate(c = factor(c, levels = seq(0,30000, 5000)))%>%
  ggplot(aes(x = v, y = values, color = c))+
  geom_line(linewidth = 1)+
  scale_color_discrete_sequential('SunsetDark')+
  geom_hline(yintercept = 0)+
  geom_point(data = data.frame(x = baselines_ %>% select(v) %>% pull() %>% unique(), 
                               y = baseline_bertrand, 
                               names = 'Price setting'),aes(x = x, y = y), colour = '#B22222')+
    geom_point(data = data.frame(x = baselines_ %>% select(v) %>% pull() %>% unique(), 
                               y = baseline_cournot, 
                               names = 'Quantity adjustment'),aes(x = x, y = y), colour = '#1f78b4')+
  facet_grid(~names)+
  labs(colour = 'Transaction cost (USD/mt)')+
  xlab('Farming cost (USD/mt)')+
  ylab('Variation from monopoly steady state population (in %)')+
  theme_bw()+
  theme(legend.position = 'bottom',
  )

ggsave(here('visuals', 'supplementary_visuals', 'supp_figure_4.png'), height = 15, width = 10, units = 'cm')
```


### 4. Impact of different substitutability

```{r, substitutability}
baseline_gamma = calibration %>%
  subset(params == 'gamma')%>%
  select(value)%>%
  pull()

gamma_sens = exploit_ %>%
  subset(spec == 'gamma')%>%
  mutate(transformation = as.numeric(transformation)*100,
         x_norm = (x-baseline_stock)/baseline_stock * 100)

gamma_sens$names = sapply(gamma_sens$names, renamer)

gamma_sens %>%
  ggplot(aes( x= transformation, y = x_norm, color = names))+
  #geom_line(aes(group = names), size = 1)+
  geom_point(size = 2.2)+
  geom_vline(xintercept = (baseline_gamma/beta)^2*100, linetype = 'dashed')+
  scale_color_manual(values = c('#B22222','#1f78b4', '#248721'))+
  ylab('Variation from baseline steady state population (in %)')+
  xlab('Product differentiation degree (in %)')+
  theme_bw()+
  labs(color = ' ', 
       shape = '')+
  theme(axis.text.x = element_text(angle = 60,
                                   hjust = 1),
        legend.position = "right",
        strip.text.x  = element_text(family = font_) ,
        axis.title.x  = element_text(family = font_, size = 9),
        axis.text = element_text(family = font_),
        axis.title.y  = element_text(family = font_, size = 9),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))
ggsave(here('visuals', 'supplementary_visuals', 'effect_of_subsidy.jpg'), width = 15, height = 10, units = 'cm')



```

### 5. Impact of joint variation of demand parameters

```{r, demand}
# Set up baselines
baseline_alpha = calibration%>%
  subset(params == 'alpha')%>%
  select(value)%>%
  pull()

baseline_beta = calibration %>%
  subset(params == 'beta')%>%
  select(value)%>%
  pull()

baseline_alpha = calibration %>%
  subset(params == 'alpha')%>%
  select(value)%>%
  pull()



renamer = function(x){
  if(x == 'ss_bertrand_lq'){
    return('Price setting')
  }else if(x == 'ss_cournot_lq'){
    return('Quantity adjustment')
  }
}

tol = .01

# Set up data 
graph_dat = exploit_ %>%
  subset(spec %in% c('alpha and gamma'))%>%
  subset(alpha > .62 * baseline_alpha)%>%
  subset(!(names %in% c('ss_monop_lq')))%>%
  mutate(alpha = as.factor(alpha/baseline_alpha))%>%
  filter((gamma< (1+ tol)*sqrt(.1) * baseline_beta & gamma > (1 - tol)*sqrt(.1)*baseline_beta) |
         (gamma< (1+ tol)*sqrt(.5) * baseline_beta & gamma > (1 - tol)*sqrt(.5)*baseline_beta)|
         (gamma< (1+ tol)*sqrt(.75) * baseline_beta & gamma > (1 - tol)*sqrt(.75)*baseline_beta)|
         (gamma< (1+ tol)*sqrt(.9) * baseline_beta & gamma > (1 - tol)*sqrt(.9)*baseline_beta))%>%
  mutate(alpha2 = as.factor(paste(alpha, Stable)),
         gamma2 = round(gamma,2),
         value2 = (x - baseline_stock)/baseline_stock*100)


work = strsplit(levels(graph_dat$alpha2), ' ')
new_levs = c()
for(k in 1:length(work)){
  to_check = work[[k]]
  if(to_check[2] =="Stable"){
    new_levs = append(new_levs, as.character(round((as.numeric(to_check[1]) - 1)*100)))
  }else{
    new_levs = append(new_levs, 'Unstable')
  }
}
levels(graph_dat$alpha2) = new_levs

# Graph
graph_dat = 
  graph_dat %>%
  mutate(gamma3 = factor(round(gamma2^2/beta^2*100,2)),
         names =  sapply(names, renamer))

graph_dat$gamma3 = paste0(graph_dat$gamma3, '%')
graph_dat$gamma3 = factor(graph_dat$gamma3, levels = c('10%', '50%', '75%', '90%'))

p = graph_dat %>%
  ggplot(aes(x = names, 
             y = value2, 
             colour = alpha2))+
  geom_point(size = 2.5)+
  facet_grid(~gamma3)+
  scale_color_manual(values = pal,
                     breaks = c("-20", "0", "20", "40", "60","80", "100"))+
  theme_bw()+
  #geom_hline(yintercept = -43, linetype = 'dotted')+
  #geom_hline(yintercept = -86, linetype = 'dotted')+
  geom_hline(yintercept = 0, linetype = 'dashed', color = 'grey')+
  xlab(' ')+
  ylab('Deviation (in %) from vertical \nmonopoly equilibrium population')+
  scale_shape_manual(values = c(4, 17, 8))+
  labs(colour = 'Demand \nvariation (in %)')+
  guides(shape = 'none',
         color=guide_legend(nrow=4, byrow=F))+
theme(axis.text.x = element_text(angle = 60,
                                   hjust = 1),
        legend.position = "right",
        strip.text.x  = element_text(family = font_) ,
        axis.title.x  = element_text(family = font_),
        axis.text = element_text(family = font_),
        axis.title.y  = element_text(family = font_, size = 9),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_), 
        aspect.ratio = 10/4)
p
ggsave(here('visuals', 'demand_evolution_sensitivity.jpg'), p, width = 20, height = 15, units = 'cm')
```

That sucks : with new specification, quantity adjustment can go wrong when demand increases by 80% in the baseline scenario... That changes our recommendations. 

Weird also because there is a steady state for Bertrand competition, while there should not be according to graphs. 

