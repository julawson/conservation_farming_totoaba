---
title: "5_Model made better"
author: "Simon"
date: "2024-01-09"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, 
                      warning = F)
options(scipen=999)

rm(list = ls())

library(tidyverse)
library("ggsci")
library(here)
library(knitr)
library(stargazer)
library(parallel)
library(RColorBrewer)

if(!(c('Fishlife')  %in% installed.packages())){
  devtools::install_github("james-thorson/FishLife")
}
#if(!(c('tinytable') %in% installed.packages())){
#  devtools::install_github("vincentarelbundock/tinytable")
#}

library(tinytable)
#library(FishLife)
library(kableExtra)

Latex = T
font_ = 'Helvetica'
color_growth = 'black'
color_vertical_monopoly = '#B22222'
color_bertrand = '#1f78b4'
color_cournot = '#248721'
palette_ = c(color_growth, color_vertical_monopoly, color_bertrand, color_cournot)
```

# I. Load data

In this section, I load data for the baseline calibration using the linear and linear quadratic cost models. 


```{r, Load Params}
calibration = read.csv(here("data", 'outputs', "calibration_params.csv"))

for(i in 1:nrow(calibration)){
  assign(calibration$params[i], calibration$value[i])
}  


# Build the 2nd order parameters from parameter list
  # Differentiate parameters for Wild and Farmed inverse demands
alpha_w = alpha
alpha_f = alpha
beta_w = beta
beta_f = beta
  # Demand functions parameters
e   = gamma/(beta_w*beta_f - (gamma^2))
a_f = (alpha_f*beta_w - alpha_w*gamma)/(beta_w*beta_f - (gamma^2))
a_w = (alpha_w*beta_f - alpha_f*gamma)/(beta_w*beta_f - (gamma^2))
b_f = beta_f/(beta_w*beta_f - (gamma^2))
b_w = beta_w/(beta_w*beta_f - (gamma^2))

calibration %>% 
  select(-X)%>%
  mutate(value = round(value,2))  %>%
  kbl() %>%
  kable_styling()

avg_toto_weight = 25.7

W_lq = read.csv(here('data', 'inputs', 'W_lq.csv'))
rm(for_display)
```

## II. Define functions
Define function where variable is either `x` i.e population stock, or `s` i.e price paid to poachers. All the parameters take default values specified in the global environment.  

* `growth(x, ...)` : logistic growth function, yields growth of population (in metric tons) 

* `pt_harvest(x,...)` : harvest (in metric tons) when trader is price taker

* `monop_harvest(x, ...)`: harvest (in metric tons) when trader is a monopolist

* `monop_harvest_lq(x, ...)`: harvest (in metric tons) when trader is a monopolist and cost structure is linear quadratic

* `cournot_harvest(x, ...)`, `bertrand_harvest(x, ...)`: harvest (in metric tons) when trader and farmer compete in *Cournot*, i.e, set quantities strategically, and *Bertrand*, i.e, set prices strategically. 

* `cournot_harvest_lq(x, ...)`, `bertrand_harvest_lq(x, ...)` : harvest  (in metric tons) when trader and farmer compete in *Cournot* i.e, set quantities strategically, and *Bertrand* i.e, set prices strategically and cost structure is linear quadratic

* `price_poachers_cournot(x, ...)`, `price_poachers_bertrand(x, ...)`: price paid to poachers (in USD/metric tons) when trader and farmer compete in *Cournot* and *Bertrand*

* `cournot_farmed(s, ...)`, `bertrand_farmed(s, ...)`: quantity farmed (in metric tons) when trader and farmer compete in *Cournot* and *Bertrand*


```{r}
growth = function(x, 
                  k.=k, 
                  r.=r){
  y = r.*x*(1-x/k.)
  return(y)
}

# I. Price taker
pt_harvest = function(x, 
                      alpha. = alpha, 
                      beta. = beta, 
                      W. = W_mid, 
                      c. = c, 
                      sigma. = sigma){
  y = ((alpha.-c.) * x^2 * sigma.^2)/(4*W. + beta. * sigma.^2 * x^2)
  return(y)
}

# II. Monopoly
monop_harvest = function(x, 
                         alpha. = alpha, 
                         c. = c, 
                         sigma. = sigma, 
                         beta. = beta, 
                         W. = W_mid){
 y = ((alpha. - c.)*sigma.^2 * x^2) / (2*beta.* sigma.^2 * x^2 + 2*W.)
 return(y)
}

monop_harvest_lq = function(x,
                            alpha. = alpha, 
                            c. = c, 
                            sigma. = sigma, 
                            beta. = beta,
                            W1. = W1,
                            W2. = W2){
  y = (sigma.^2 * x^2 * (alpha. - c.) - W1.*sigma.*x)/(2*(beta.*sigma.^2 * x^2 + W2.))
  return(y)
}


# III. Cournot

cournot_harvest = function(x, 
                             alpha_f. = alpha_f, 
                             alpha_w. = alpha_w, 
                             beta_f. = beta_f, 
                             beta_w. = beta_w, 
                             gamma. = gamma, 
                             sigma. = sigma, 
                             c. = c, 
                             v. = v, 
                             W. = W_mid){
  y = ((sigma.^2)*(x^2)*(2*beta_f.*(alpha_w. - c.) - gamma.*(alpha_f. - v.)))/(4*beta_f.*W. + (sigma.^2)*(x^2)*(4*beta_f.*beta_w. - (gamma.^2)))
  return(y)
}

cournot_harvest_lq = function(x, 
                              alpha_f. = alpha_f, 
                              alpha_w. = alpha_w, 
                              beta_f. = beta_f, 
                              beta_w. = beta_w, 
                              gamma. = gamma, 
                              sigma. = sigma, 
                              c. = c, 
                              v. = v, 
                              W1. = W1, 
                              W2. = W2){
 y = ((2*beta_f. * (alpha_w. - c.) - gamma. * (alpha_w. -v.))*sigma.^2 * x^2 - 2*beta_f.*W1.*sigma.*x)/(4*beta_f.*W2. + (4*beta_f.*beta_w. - gamma.^2)*sigma.^2 * x^2)
 return(y)
}

price_poachers_cournot = function(x,
                                  alpha_f. = alpha_f, 
                                  alpha_w. = alpha_w, 
                                  beta_f. = beta_f, 
                                  beta_w. = beta_w, 
                                  gamma. = gamma, 
                                  sigma. = sigma, 
                                  c. = c, 
                                  v. = v, 
                                  W. = W_mid){
  y = (2*W.*(2*beta_f.*(alpha_w. - c.) - gamma.*(alpha_f. - v.)))/((sigma.^2)*(x^2)*(4*beta_f.*beta_w. - gamma.^2) + 4*beta_f.*W.)
  return(y)
}

cournot_farmed = function(s, 
                            alpha_f. = alpha_f, 
                            alpha_w. = alpha_w, 
                            beta_f. = beta_f, 
                            beta_w. = beta_w, 
                            gamma. = gamma, 
                            sigma. = sigma, 
                            c. = c, 
                            v. = v){
  y = (2 * beta_w. * (alpha_f. - v.) - gamma.* (alpha_w. - (s + c.)) )/(4*beta_w.*beta_f. - gamma.^2)
  return(y)
}

# IV. Bertrand

price_poachers_bertrand = function(x, 
                                   a_f. = a_f, 
                                   a_w. = a_w, 
                                   b_f. = b_f, 
                                   b_w. = b_w, 
                                   e.  = e, 
                                   c. = c, 
                                   v. = v, 
                                   sigma. = sigma, 
                                   W. = W_mid){
  y = (2*W.*b_w.*( b_f.*(2*a_w. + e.*v.) + c.*((e.^2) - 2*b_f.*b_w.) + e.*a_f.))/((sigma.^2)*(x^2)*(4*b_f.*b_w. - (e.^2)) + 2*W.*b_w.*(2*b_w.*b_f. - (e.^2)))
  return(y)
}

bertrand_harvest = function(x,
                              sigma. = sigma, 
                              a_f. = a_f, 
                              a_w. = a_w, 
                              b_f. = b_f, 
                              b_w. = b_w, 
                              e. = e, 
                              v. = v, 
                              c. = c, 
                              W. = W_mid){
  y = ((sigma.^2)*(x^2)*b_w.*(b_f.*(2*a_w.+e.*v.) + c.*((e.^2)- 2*b_f.*b_w.) + e.*a_f.))/((sigma.^2)*(x^2)*(4*b_w.*b_f. - (e.^2)) + 2*W.*b_w.*(2*b_f.*b_w. - (e.^2)))
  return(y)
}

bertrand_harvest_lq = function(x,
                               sigma. = sigma, 
                               a_f. = a_f, 
                               a_w. = a_w, 
                               b_f. = b_f, 
                               b_w. = b_w, 
                               e. = e, 
                               v. = v, 
                               c. = c, 
                               W1. = W1, 
                               W2. = W2){
  y1 = b_w.*(sigma.^2 * x^2 *((2*a_w. +e.*v.)*b_f. + e.*a_f.) + (c. + W1. * sigma. * b_w. * x)*(e.^2 - 2*b_w. *b_f.))
  y2 = 2*W2.*b_w.*(2*b_f.* b_w. - e.^2) + (4*b_f.*b_w. - e.^2)*sigma.^2*x^2
  z = y1*y2
  return(z)
}

price_poacher_bertrand_lq = function(x,
                               sigma. = sigma, 
                               a_f. = a_f, 
                               a_w. = a_w, 
                               b_f. = b_f, 
                               b_w. = b_w, 
                               e. = e, 
                               v. = v, 
                               c. = c, 
                               W1. = W1, 
                               W2. = W2){
  y = 2*b_w.*W2.*((2*a_w. + e.*v.)*b_f. + e.*a_f. + c.*(e.^2 - b_f.*b_w.)) + W1.*sigma.*x*(4*b_f.*b_w. - e.^2)
  z = sigma.^2 * x^2 * (4*b_w.*b_f. - e.^2) + 4*b_w.*W2.*(2*b_f.*b_w - e.^2)
  result = y/z
  return(result)
}

composite_bertrand_lq = function(x,
                               sigma. = sigma, 
                               a_f. = a_f, 
                               a_w. = a_w, 
                               b_f. = b_f, 
                               b_w. = b_w, 
                               e. = e, 
                               v. = v, 
                               c. = c, 
                               W1. = W1, 
                               W2. = W2){
  y = b_w. * ((2*a_w. +e.*v.)*b_f. + e.*a_f. + (price_poacher_bertrand_lq(x)+c.)*(e.^2 - 2*b_w.*b_f))/(4*b_f.*b_w. - e.^2)
  return(y)
}

bertrand_farmed = function(s, 
                             a_f. = a_f, 
                             a_w. = a_w, 
                             b_f. = b_f, 
                             b_w. = b_w, 
                             e. = e, 
                             c. = c, 
                             v. = v){
  y = b_f. *(2*b_w.*a_f. + v.*(e.^2 - 2*b_w.*b_f.) + e.*(a_w. + (s+c.)*b_w.))/(4*b_f.*b_w. - e.^2)
  return(y)
}

```

## III. Generate results

Generate results saved at `~/data/outputs/results_all_models.csv` :

* Set cost variables using `W_lq`: each row corresponds to a cost parameter $W$, $W_1$ and $W_2$
```{r, Results}
# Initiate data storage
storage = data.frame(0,0,0,0,0,0,0,0)
colnames(storage) = c('x','names','values','AC', 'W_mid', 'W1', 'W2',"quantile")

# Run model for every W configuration
for(row in 1:nrow(W_lq)){
  W_mid = W_lq[row,4]
  W1 = W_lq[row,2]
  W2 = W_lq[row,3]
  quantile = W_lq[row,5]
  
  result1 = data.frame(x = seq(1,k,.5 ))%>%
    mutate(growth= growth(x),
           # Harvests with quadratic and linear-quadratic costs
           monop_harvest = monop_harvest(x),
           monop_harvest_lq = monop_harvest_lq(x),
           cournot_harvest = cournot_harvest(x),
           cournot_harvest_lq = cournot_harvest_lq(x),
           bertrand_harvest = bertrand_harvest(x),
           bertrand_harvest_lq = composite_bertrand_lq(x),
           # Steady states
           ss_monop = monop_harvest - growth, 
           ss_monop_lq = monop_harvest_lq - growth, 
           ss_cournot = cournot_harvest - growth, 
           ss_cournot_lq = cournot_harvest_lq - growth,
           ss_bertrand = bertrand_harvest - growth, 
           ss_bertrand_lq = bertrand_harvest_lq - growth,
           # Prices
           price_poachers_lq = price_poacher_bertrand_lq(x),
           price_poachers_bertrand = price_poachers_bertrand(x))
  
  # Put data in long format
  errr = result1 %>% 
    pivot_longer(-x, names_to = 'names', values_to = 'values')%>%
    subset(names %in% c('ss_monop',
                        'ss_monop_lq',
                        'ss_cournot',
                        'ss_cournot_lq',
                        'ss_bertrand',
                        'ss_bertrand_lq'))%>%
    subset(values > -.1)%>%
    subset(values < .1)%>%
    mutate(AC = W_lq[row,1],
           W_mid = W_mid, 
           W1 = W1, 
           W2 = W2,
           quantile = quantile)
  # Store
  storage = rbind(storage, errr)
}


# Goal is to format to have only 1 steady state value : filter out the points around the steady states. 
cost = unique(storage$AC)[2]

# Initiate storage
final_dat = data.frame(0,0,0,0,0,0,0,0,0)
colnames(final_dat) = c(colnames(storage), 'lag_sign')

# Mutate ac_quantile to have 1 combination to scan through
storage = storage %>%
  mutate(ac_quantile = paste0(AC,quantile))

# Loop over name and ac_quantile combination
for(name in unique(storage$names)){
  for(ac_quant in unique(storage$ac_quantile)){
    study = storage %>%
      subset(names == name)%>%
      subset(ac_quantile == ac_quant)%>%     # Subset data 
      mutate(lag_sign = c(0, diff(sign(values))), # Mutate to get sign change and value of steady state change
             lag_val = c(0, diff(x)))
    # Define cut vector to scan through each zone : cuts are defined as jumps in x value 
      cuts_ = which(study$lag_val>5 | study$lag_val < -5) - 1
      cuts_ = c(0,cuts_, nrow(study))
    # Use cuts vector to scan through
    for(cut in 1:(length(cuts_)-1)){
      lb_ = cuts_[cut]+1
      ub_ = cuts_[cut+1]
    
      to_check = study[lb_: ub_,]%>%
        subset(lag_sign !=0)%>%
        subset(lag_val>0)%>% # Keep only when the lag value is positive : otherwise, it means a change in sequence or type of equilibrium
        select(-c(lag_val, ac_quantile))
    
      final_dat = rbind(final_dat, to_check)
    }
  }
  
}

# Eventually, tell if equilibrium is stable using lag_sign 
final_dat = final_dat %>%
  subset(AC>0)%>%
  mutate(Stable = ifelse(lag_sign>0,'Stable', 'Unstable'))

# Save

write.csv(final_dat, here('data', 'outputs', 'results_all_models.csv'))
              
```



### Graph outputs : 

First, illustrate the new equilibria with the same $W$ value and the middle point solution for $W_1$ and $W_2$ in the linear quadratic cost of effort specification. 

```{r, New equilibrium}

W_choice = W_lq %>%
  subset(quantiles == 90)%>%
  filter(W_mid < 3 & W_mid >2)%>%
  unlist()

W_mid    = W_choice['W_mid']
W1       = W_choice['W1']
W2       = W_choice['W2']
quantile = W_choice['quantiles']

result1 = data.frame(x = seq(1,k,.5 ))%>%
  mutate(growth= growth(x),
         monop_harvest = monop_harvest(x),
         monop_harvest_lq = monop_harvest_lq(x),
         cournot_harvest = cournot_harvest(x),
         cournot_harvest_lq = cournot_harvest_lq(x),
         bertrand_harvest = bertrand_harvest(x),
         bertrand_harvest_lq = composite_bertrand_lq(x),
         ss_monop = monop_harvest - growth, 
         ss_monop_lq = monop_harvest_lq - growth, 
         ss_cournot = cournot_harvest - growth, 
         ss_cournot_lq = cournot_harvest_lq - growth,
         ss_bertrand = bertrand_harvest - growth, 
         ss_bertrand_lq = bertrand_harvest_lq - growth,
         price_poachers_lq = price_poacher_bertrand_lq(x),
         price_poachers_bertrand = price_poachers_bertrand(x))
# Format:
renamer= function(x){
  if(x %in% c('monop_harvest', 'monop_harvest_lq')){
    return('Vertical Monopoly')
  }else if(x %in% c('cournot_harvest', 'cournot_harvest_lq')){
    return('Quantity adjustment')
  }else if(x %in% c('bertrand_harvest', 'bertrand_harvest_lq')){
    return('Price setting')
  }else if(x %in% c('growth')){
    return('Growth')
  }
}

renamer2 = function(x){
  checker = strsplit(x, '_')[[1]]
  if(checker[1]=='growth'){
    return('Linear quadratic cost')
  }else{
    if(length(checker)<3){
      return('Quadratic cost')
    }else{
      return('Linear quadratic cost')
    }
  }
}

rounder = function(x){
  return(max(0,x))
}

dat_ = result1 %>%
  pivot_longer(-x, 
               values_to = 'values', 
               names_to = 'names')%>%
  subset(names %in% c('growth', 
                      'monop_harvest', 
                      'monop_harvest_lq', 
                      'cournot_harvest',
                      'cournot_harvest_lq', 
                      'bertrand_harvest', 
                      'bertrand_harvest_lq'))
dat_$new_names = sapply(dat_$names, renamer)
dat_$values2 = sapply(dat_$values, rounder)
dat_$cost_structure = sapply(dat_$names, renamer2)

dat_%>%
  subset(x %%2 == 0)%>%
  ggplot(aes(x = x,
             y = values2, 
             color = new_names))+
  geom_line(aes(linetype = cost_structure), size = 1)+
  scale_linetype_manual(values=c("solid", "twodash"))+
  scale_color_manual(values = palette_)+
  theme_bw()+
  guides(
    color = guide_legend(
      title = " ",  # Title for the first column
      ncol = 2              # Number of columns
    ),
    linetype = guide_legend(
      title = ' ',
      ncol = 2
    ))+
  xlab('Population')+
  ylab('Harvest')+
  theme(legend.position = 'bottom',
        strip.text.x  = element_text(family = font_) ,
        axis.title.x  = element_text(family = font_),
        axis.text = element_text(family = font_),
        axis.title.y  = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))
```

To understand the impact of different $W_1$ & $W_2$ divides : 

```{r, understand different W}
store = data.frame(matrix(nrow = 0, ncol= ncol(result1)+1))
colnames(store)= c(colnames(result1), 'quantile')

for(xx in c(21, 25, 29)){
  W_mid    = W_lq[xx,4]
  W1       = W_lq[xx,2]
  W2       = W_lq[xx,3]
  quantile = W_lq[xx,5]
  
  result1 = data.frame(x = seq(1,k,.5 ))%>%
    mutate(growth= growth(x),
           monop_harvest = monop_harvest(x),
           monop_harvest_lq = monop_harvest_lq(x),
           cournot_harvest = cournot_harvest(x),
           cournot_harvest_lq = cournot_harvest_lq(x),
           bertrand_harvest = bertrand_harvest(x),
           bertrand_harvest_lq = composite_bertrand_lq(x),
           ss_monop = monop_harvest - growth, 
           ss_monop_lq = monop_harvest_lq - growth, 
           ss_cournot = cournot_harvest - growth, 
           ss_cournot_lq = cournot_harvest_lq - growth,
           ss_bertrand = bertrand_harvest - growth, 
           ss_bertrand_lq = bertrand_harvest_lq - growth,
           price_poachers_lq = price_poacher_bertrand_lq(x),
           price_poachers_bertrand = price_poachers_bertrand(x),
           quantile = paste0('W1 =', round(W1,1), ' & W2 = ', round(W2,1)))
  store = rbind(store, 
                result1)
}

store$quantile = factor(store$quantile, levels = c("W1 =12947.4 & W2 = 0.4",
                                                   "W1 =7193 & W2 = 1.9",
                                                   "W1 =1438.6 & W2 = 3.4"))

# Format:
renamer= function(x){
  if(x %in% c('monop_harvest', 'monop_harvest_lq')){
    return('Vertical Monopoly')
  }else if(x %in% c('cournot_harvest', 'cournot_harvest_lq')){
    return('Quantity adjustment')
  }else if(x %in% c('bertrand_harvest', 'bertrand_harvest_lq')){
    return('Price setting')
  }else if(x %in% c('growth')){
    return('Growth')
  }
}

renamer2 = function(x){
  checker = strsplit(x, '_')[[1]]
  if(length(checker)<3){
    return('Quadratic cost')
  }else{
    return('Linear quadratic cost')
  }
}

rounder = function(x){
  return(max(0,x))
}

dat_ = store %>%
  pivot_longer(-c(x,quantile), 
               values_to = 'values', 
               names_to = 'names')%>%
  subset(names %in% c('growth', 
                      'monop_harvest', 
                      'monop_harvest_lq', 
                      'cournot_harvest',
                      'cournot_harvest_lq', 
                      'bertrand_harvest', 
                      'bertrand_harvest_lq'))
dat_$new_names = sapply(dat_$names, renamer)
dat_$values2 = sapply(dat_$values, rounder)
dat_$cost_structure = sapply(dat_$names, renamer2)

p = dat_%>%
  subset(x %% 2 == 0)%>%
  ggplot(aes(x = x,
             y = values2, 
             color = new_names))+
  geom_line(aes(linetype = cost_structure), linewidth = 1)+
  facet_grid(~quantile)+
  scale_linetype_manual(values=c("twodash", "solid"))+
  scale_color_manual(values = palette_)+
  theme_bw()+
  guides(
    color = guide_legend(
      title = " ",  # Title for the first column
      ncol = 2              # Number of columns
    ),
    linetype = guide_legend(
      title = ' ',
      ncol = 2
    ))+
  xlab('Population')+
  ylab('Harvest')+
  theme(legend.position = 'bottom',
        strip.text.x  = element_text(family = font_) ,
        axis.title.x  = element_text(family = font_),
        axis.text = element_text(family = font_),
        axis.title.y  = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))
p
if(!file.exists(here('visuals', 'supplementary_visuals', 'equilibria_with_W1_W2.png'))){
  p
  ggsave(here('visuals', 'supplementary_visuals', 'equilibria_with_W1_W1.png'),
        width = 30,
        height = 15, 
        units = 'cm') 
}
```

Clearly, the choice of $W_1$ and $W_2$ is important with respect to the anticipated equilibrium in the *vertical monopoly* case : with a linear-quadratic cost function, we no longer can say the monopoly will achieve a *healthy* steady state population. The results in the **post intervention** world are robust to the cost specification, and guarantee population increases in the *quantity adjustment* scenario, while population may marginally diminish in the *price setting* scenario. 

```{r, Equilibria}
# Rename:
costs = unique(W_lq$Cost)

rename_W = function(x){
  if(x==costs[1]){
    return('Low Effort Cost')
  }else if(x==costs[2]){
    return('Mid. Effort Cost')
  }else if(x==costs[3]){
    return('High Effort Cost')
  }
}

rename_scenario = function(x){
  if(x %in% c('ss_monop_lq', 'ss_bertrand_lq', 'ss_cournot_lq')){
    return('Linear-Quadratic cost ')
  }else{
    return('Quadratic cost')
  }
}

rename_scenario2 = function(x){
  if(x %in% c('ss_bertrand', 'ss_bertrand_lq')){
    return('Bertrand')
  }else if(x %in% c('ss_cournot', 'ss_cournot_lq')){
    return('Cournot')
  }else if(x %in% c('ss_monop_lq', 'ss_monop')){
    return('Monopoly')
  }
}
rename_quantiles = function(x){
  return(paste0(x,'%'))
}


##### Final Graphs
final_dat %>%
  subset(AC>0)%>%
  subset(names %in% c('ss_monop_lq', 'ss_monop'))%>%
  mutate(new_AC = factor(sapply(AC, rename_W), 
                         levels = c('Low Effort Cost', 
                                    'Mid. Effort Cost', 
                                    'High Effort Cost')),
         new_names = sapply(names, rename_scenario),
         tamr = paste(new_names, new_AC, sep = ' '),
         new_quantile = sapply(quantile, rename_quantiles))%>%
  subset(new_quantile %in% c('10%','20%', '50%', '80%','90%'))%>%
  ggplot(aes(x = new_names, y = x, color = Stable))+
  scale_color_manual(values = c('darkblue', 'brown'))+
  geom_point(size = 2)+
  #scale_color_continuous('Estimate of unit effort cost', type = 'viridis')+
  facet_grid(new_AC~new_quantile)+
  theme_bw()+
  xlab(' ')+
  ylab(' ')+
  ggtitle("Vertical monopoly steady states with linear and linear quadratic costs")+
  theme(axis.text.x = element_text(angle = 60, 
                                   hjust = 1,
                                   family = font_), 
        axis.title.x= element_text(family = font_),
        axis.title.y = element_text(family = font_),
        plot.title = element_text(hjust = 0.5,
                                  family = font_),
        strip.text.x  = element_text(family = font_) ,
        axis.text = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))
```

```{r, Cournot}

final_dat %>%
  subset(AC>0)%>%
  subset(names %in% c('ss_cournot_lq', 'ss_cournot'))%>%
  mutate(new_AC = factor(sapply(AC, rename_W), 
                         levels = c('Low Effort Cost', 
                                    'Mid. Effort Cost', 
                                    'High Effort Cost')),
         new_names = sapply(names, rename_scenario),
         tamr = paste(new_names, new_AC, sep = ' '),
         new_quantile = sapply(quantile, rename_quantiles))%>%
  subset(new_quantile %in% c('10%','20%', '50%', '80%','90%'))%>%
  ggplot(aes(x = new_names, y = x, color = Stable))+
  scale_color_manual(values = c('darkblue', 'brown'))+
  geom_point(size = 2)+
  #scale_color_continuous('Estimate of unit effort cost', type = 'viridis')+
  facet_grid(new_AC~new_quantile)+
  theme_bw()+
  xlab(' ')+
  ylab(' ')+
  ggtitle("Quantity adjustment steady states with linear and linear quadratic costs")+
  theme(axis.text.x = element_text(angle = 60, 
                                   hjust = 1,
                                   family = font_), 
        axis.title.x= element_text(family = font_),
        axis.title.y = element_text(family = font_),
        plot.title = element_text(hjust = 0.5,
                                  family = font_),
        strip.text.x  = element_text(family = font_) ,
        axis.text = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))
```

```{r, Bertrand}
final_dat %>%
  subset(AC>0)%>%
  subset(names %in% c('ss_bertrand_lq', 'ss_bertrand'))%>%
  mutate(new_AC = factor(sapply(AC, rename_W), 
                         levels = c('Low Effort Cost', 
                                    'Mid. Effort Cost', 
                                    'High Effort Cost')),
         new_names = sapply(names, rename_scenario),
         tamr = paste(new_names, new_AC, sep = ' '),
         new_quantile = sapply(quantile, rename_quantiles))%>%
  subset(new_quantile %in% c('10%','20%', '50%', '80%','90%'))%>%
  ggplot(aes(x = new_names, y = x, color = Stable))+
  scale_color_manual(values = c('darkblue', 'brown'))+
  geom_point(size = 2)+
  #scale_color_continuous('Estimate of unit effort cost', type = 'viridis')+
  facet_grid(new_AC~new_quantile)+
  theme_bw()+
  xlab(' ')+
  ylab(' ')+
  ggtitle("Price setting steady states with linear and linear quadratic costs")+
  theme(axis.text.x = element_text(angle = 60, 
                                   hjust = 1,
                                   family = font_), 
        axis.title.x= element_text(family = font_),
        axis.title.y = element_text(family = font_),
        plot.title = element_text(hjust = 0.5,
                                  family = font_),
        strip.text.x  = element_text(family = font_) ,
        axis.text = element_text(family = font_),
        legend.text = element_text(family = font_), 
        legend.title = element_text(family = font_))
```

Define bio-economic performance by combining population variables (stock and harvest) with price and profit data from economic model. 

```{r, bioeconomic performance}

baseline_quantile = 90
profit = function(param){
  # Variable assignment
  to_assign = names(param)
  
  if('Stable' %in% to_assign){
    to_assign = to_assign[!(to_assign %in% c('Stable', 'values', 'AC', 'quantile'))]
    }
  for(variable in to_assign){
    if(variable == 'names'){
      assign(variable,
             unlist(param[variable]))
    }else{
        assign(variable, 
               as.numeric(unlist(param[variable])))
    }
  }
  W = W_mid
  
  alpha_w = alpha
  alpha_f = alpha
  beta_w = beta
  beta_f = beta
  # Demand functions parameters
  e   = gamma/(beta_w*beta_f - (gamma^2))
  a_f = (alpha_f*beta_w - alpha_w*gamma)/(beta_w*beta_f - (gamma^2))
  a_w = (alpha_w*beta_f - alpha_f*gamma)/(beta_w*beta_f - (gamma^2))
  b_f = beta_f/(beta_w*beta_f - (gamma^2))
  b_w = beta_w/(beta_w*beta_f - (gamma^2))
  
  if(names == 'ss_monop'){
    # Redefine harvest
    monop_harvest = function(x, 
                             alpha. = alpha, 
                             c. = c, 
                             sigma. = sigma, 
                             beta. = beta, 
                             W. = W_mid){
    y = ((alpha. - c.)*sigma.^2 * x^2) / (2*beta.* sigma.^2 * x^2 + 2*W.)
    return(y)
    }
    # Define outputs : 
      # Poached harvest
    poached_harvest = monop_harvest(x)
      # Farmed harvest : 
    farmed_harvest = 0
    # Prices paid:
    price_poachers = (alpha_w - c)*W/(beta*sigma^2*x^2+W)
    price_retail = (alpha - beta*poached_harvest)
    # Profits:
      # Profit from poaching
    profit_poaching = (alpha - beta * poached_harvest - c - price_poachers)*poached_harvest
      # Profit from farming
    profit_farming = 0
    profit_fishermen = (price_poachers*sigma*x)^2/(4*W)
    
  }else if(names == 'ss_monop_lq'){
    # Redefine harvest
    monop_harvest_lq = function(x,
                                alpha. = alpha, 
                                c. = c, 
                                sigma. = sigma, 
                                beta. = beta,
                                W1. = W1,
                                W2. = W2){
    y = (sigma.^2 * x^2 * (alpha. - c.) - W1.*sigma.*x)/(2*(beta.*sigma.^2 * x^2 + W2.))
    return(y)
    }
    # Harvest:
    poached_harvest = monop_harvest_lq(x)
    farmed_harvest = 0
    # Price : 
    price_poachers = (W2*(alpha-c)+beta*W1*sigma*x)/(beta*sigma^2*x^2 + W2)
    price_retail = (alpha - beta*poached_harvest)
    # Redefine profit
    profit_poaching = (alpha - beta*poached_harvest - c - price_poachers)*poached_harvest
    profit_fishermen = price_poachers * poached_harvest - W1*((price_poachers * sigma * x -W1)/(2*W2)) - W2*((price_poachers * sigma * x - W1)/(2*W2))^2
    profit_farming = 0
  }else if(names == 'ss_cournot'){
    # Redefine harvests and price paid to poachers
    cournot_harvest = function(x, 
                               alpha_f. = alpha_f, 
                               alpha_w. = alpha_w, 
                               beta_f. = beta_f, 
                               beta_w. = beta_w, 
                               gamma. = gamma, 
                               sigma. = sigma, 
                               c. = c, 
                               v. = v, 
                               W. = W_mid){
        y = ((sigma.^2)*(x^2)*(2*beta_f.*(alpha_w. - c.) - gamma.*(alpha_f. - v.)))/(4*beta_f.*W. + (sigma.^2)*(x^2)*(4*beta_f.*beta_w. - (gamma.^2)))
        return(y)
      }
    
    price_poachers_cournot = function(x,
                                      alpha_f. = alpha_f, 
                                      alpha_w. = alpha_w, 
                                      beta_f. = beta_f, 
                                      beta_w. = beta_w, 
                                      gamma. = gamma, 
                                      sigma. = sigma, 
                                      c. = c, 
                                      v. = v, 
                                      W. = W_mid){
    y = (2*W.*(2*beta_f.*(alpha_w. - c.) - gamma.*(alpha_f. - v.)))/((sigma.^2)*(x^2)*(4*beta_f.*beta_w. - gamma.^2) + 4*beta_f.*W.)
    return(y)
    }

    cournot_farmed = function(s, 
                              alpha_f. = alpha_f, 
                              alpha_w. = alpha_w, 
                              beta_f. = beta_f, 
                              beta_w. = beta_w, 
                              gamma. = gamma, 
                              sigma. = sigma, 
                              c. = c, 
                              v. = v){
    y = (2 * beta_w. * (alpha_f. - v.) - gamma.* (alpha_w. - (s + c.)) )/(4*beta_w.*beta_f. - gamma.^2)
    return(y)
    }
    
    # Results  
    poached_harvest = cournot_harvest(x)
    price_poachers = price_poachers_cournot(x)
    farmed_harvest = cournot_farmed(price_poachers)
    
    price_retail = (alpha_w - beta_w * poached_harvest - gamma * farmed_harvest)
    profit_poaching = (alpha_w - beta_w * poached_harvest - gamma * farmed_harvest - c - price_poachers)*poached_harvest
    profit_farming  = (alpha_f - beta_f * farmed_harvest - gamma * poached_harvest - v) * farmed_harvest
    profit_fishermen = (price_poachers*x*sigma)^2/(4*W)
    
  }else if(names == 'ss_cournot_lq'){
    cournot_harvest_lq = function(x, 
                                  alpha_f. = alpha_f, 
                                  alpha_w. = alpha_w, 
                                  beta_f. = beta_f, 
                                  beta_w. = beta_w, 
                                  gamma. = gamma, 
                                  sigma. = sigma, 
                                  c. = c, 
                                  v. = v, 
                                  W1. = W1, 
                                  W2. = W2){
    y = ((2*beta_f. * (alpha_w. - c.) - gamma. * (alpha_w. -v.))*sigma.^2 * x^2 - 2*beta_f.*W1.*sigma.*x)/(4*beta_f.*W2. + (4*beta_f.*beta_w. - gamma.^2)*sigma.^2 * x^2)
    return(y)
    }
    
    poached_harvest = cournot_harvest_lq(x)
    price_poachers = (2*W2*(2*beta_f*(alpha_w - c) - gamma*(alpha_f - v)) + W1*sigma*x*(4*beta_f*beta_w - gamma^2))/(4*beta_f*W2 + (4*beta_f*beta_w - gamma^2)*sigma^2*x^2)
    farmed_harvest = (2*beta_w*(alpha_f - v) - gamma*(alpha_w - price_poachers - c))/(4*beta_w*beta_f - gamma^2)
    
    price_retail = (alpha_w - beta_w * poached_harvest - gamma * farmed_harvest)
    profit_poaching = (alpha_w - beta_w * poached_harvest - gamma * farmed_harvest - price_poachers - c)*poached_harvest
    profit_farming =  (alpha_f - beta_f * farmed_harvest - gamma * poached_harvest - v)* farmed_harvest
    profit_fishermen = price_poachers * poached_harvest - W1*((price_poachers * sigma * x -W1)/(2*W2)) - W2*((price_poachers * sigma * x - W1)/(2*W2))^2
    
  }else if(names == 'ss_bertrand'){
    
    price_poachers_bertrand = function(x, 
                                       a_f. = a_f, 
                                       a_w. = a_w, 
                                       b_f. = b_f, 
                                       b_w. = b_w, 
                                       e.  = e, 
                                       c. = c, 
                                       v. = v, 
                                       sigma. = sigma, 
                                       W. = W_mid){
    y = (2*W.*b_w.*( b_f.*(2*a_w. + e.*v.) + c.*((e.^2) - 2*b_f.*b_w.) + e.*a_f.))/((sigma.^2)*(x^2)*(4*b_f.*b_w. - (e.^2)) + 2*W.*b_w.*(2*b_w.*b_f. - (e.^2)))
    return(y)
    }

    bertrand_harvest = function(x,
                                sigma. = sigma, 
                                a_f. = a_f, 
                                a_w. = a_w, 
                                b_f. = b_f, 
                                b_w. = b_w, 
                                e. = e, 
                                v. = v, 
                                c. = c, 
                                W. = W_mid){
    y = ((sigma.^2)*(x^2)*b_w.*(b_f.*(2*a_w.+e.*v.) + c.*((e.^2)- 2*b_f.*b_w.) + e.*a_f.))/((sigma.^2)*(x^2)*(4*b_w.*b_f. - (e.^2)) + 2*W.*b_w.*(2*b_f.*b_w. - (e.^2)))
    return(y)
    }
    bertrand_farmed = function(s, 
                               a_f. = a_f, 
                               a_w. = a_w, 
                               b_f. = b_f, 
                               b_w. = b_w, 
                               e. = e, 
                               c. = c, 
                               v. = v){
    y = b_f. *(2*b_w.*a_f. + v.*(e.^2 - 2*b_w.*b_f.) + e.*(a_w. + (s+c.)*b_w.))/(4*b_f.*b_w. - e.^2)
    return(y)
    }
    
    poached_harvest = bertrand_harvest(x)
    price_poachers = price_poachers_bertrand(x)
    farmed_harvest = bertrand_farmed(price_poachers)
    price_retail = (alpha_w - beta_w * poached_harvest - gamma * farmed_harvest)
    profit_fishermen = (price_poachers*x*sigma)^2/(4*W)
    profit_poaching = (alpha_w - beta_w * poached_harvest - gamma * farmed_harvest - c - price_poachers) * poached_harvest
    profit_farming = (alpha_f - beta_f * farmed_harvest - gamma * poached_harvest - v)*farmed_harvest
    
  }else if(names == 'ss_bertrand_lq'){
    price_poacher_bertrand_lq = function(x,
                                         sigma. = sigma, 
                                         a_f. = a_f, 
                                         a_w. = a_w, 
                                         b_f. = b_f, 
                                         b_w. = b_w, 
                                         e. = e, 
                                         v. = v, 
                                         c. = c, 
                                         W1. = W1, 
                                         W2. = W2){
    y = 2*b_w.*W2.*((2*a_w. + e.*v.)*b_f. + e.*a_f. + c.*(e.^2 - b_f.*b_w.)) + W1.*sigma.*x*(4*b_f.*b_w. - e.^2)
    z = sigma.^2 * x^2 * (4*b_w.*b_f. - e.^2) + 4*b_w.*W2.*(2*b_f.*b_w - e.^2)
    result = y/z
    return(result)
    }

    composite_bertrand_lq = function(x,
                                     sigma. = sigma, 
                                     a_f. = a_f, 
                                     a_w. = a_w, 
                                     b_f. = b_f, 
                                     b_w. = b_w, 
                                     e. = e, 
                                     v. = v, 
                                     c. = c, 
                                     W1. = W1, 
                                     W2. = W2){
    y = b_w. * ((2*a_w. +e.*v.)*b_f. + e.*a_f. + (price_poacher_bertrand_lq(x)+c.)*(e.^2 - 2*b_w.*b_f))/(4*b_f.*b_w. - e.^2)
    return(y)
    }
    
    price_poachers = price_poacher_bertrand_lq(x)
    poached_harvest = composite_bertrand_lq(price_poachers)
    farmed_harvest = b_f*(b_w*(2*a_f + e*(price_poachers + c)) + e*a_w + v*(e^2 - 2*b_w*b_f))/(4*b_f*b_w - e^2)
    
    price_retail = (alpha_w - beta_w * poached_harvest - gamma * farmed_harvest)
    profit_poaching = (alpha_w - beta_w * poached_harvest - gamma*farmed_harvest - price_poachers - c)*poached_harvest
    profit_farming = (alpha_f - beta_f * farmed_harvest - gamma * poached_harvest -v)*farmed_harvest
    profit_fishermen = price_poachers * poached_harvest - W1*((price_poachers * sigma * x -W1)/(2*W2)) - W2*((price_poachers * sigma * x - W1)/(2*W2))^2
  }
  
  result = data.frame(names, x, poached_harvest, farmed_harvest, price_retail, price_poachers, profit_poaching, profit_farming, profit_fishermen, lag_sign, W1, W2, W_mid)
  rownames(result) = NULL
  #result = t(as.data.frame(result))
  colnames(result) = c( 'names','x', 'poached_harvest', 'farmed_harvest','price_retail', 'price_poachers', 'profit_poaching', 'profit_farming', 'profit_fishermen','stability', 'W1', 'W2', 'W')
  return(result)
}
storage = apply(final_dat,
                1,
                profit)
storage = bind_rows(storage)%>%
  mutate(ag_profit = profit_poaching + profit_farming + profit_fishermen)

# Define baselines

W_baseline = calibration%>%
  subset(params == 'W_mid')%>%
  select(value)%>%
  pull

Wlq_baseline = W_lq %>%
  subset(W_mid == W_baseline) %>%
  subset(quantiles == baseline_quantile)
W1_baseline = Wlq_baseline %>%
  select(W1) %>%
  pull()
W2_baseline = Wlq_baseline %>%
  select(W2) %>%
  pull()
# Normalize :
## baseline profit
baseline_profit_monop = storage %>%
  subset(names == 'ss_monop')%>%
  filter(W < 1.1*W_baseline & W>.98*W_baseline)%>%
  filter(W1 < 1.1* W1_baseline & W1 > .98*W1_baseline)%>%
  filter(W2 < 1.1 *W2_baseline & W2_baseline >.98 * W2_baseline)%>%
  select(profit_poaching)%>%
  pull()

baseline_profit_fishermen = storage %>%
  subset(names == 'ss_monop')%>%
  filter(W < 1.1*W_baseline & W>.98*W_baseline)%>%
  filter(W1 < 1.1* W1_baseline & W1 > .98*W1_baseline)%>%
  filter(W2 < 1.1 *W2_baseline & W2_baseline >.98 * W2_baseline)%>%
  select(profit_fishermen)%>%
  pull()

baseline_profit_farming = storage %>%
  subset(names == 'ss_monop')%>%
  filter(W < 1.1*W_baseline & W>.98*W_baseline)%>%
  filter(W1 < 1.1* W1_baseline & W1 > .98*W1_baseline)%>%
  filter(W2 < 1.1 *W2_baseline & W2_baseline >.98 * W2_baseline)%>%
  select(profit_farming)%>%
  pull()

baseline_ag_profit = storage %>%
  subset(names == 'ss_monop')%>%
  filter(W < 1.1*W_baseline & W>.98*W_baseline)%>%
  filter(W1 < 1.1* W1_baseline & W1 > .98*W1_baseline)%>%
  filter(W2 < 1.1 *W2_baseline & W2_baseline >.98 * W2_baseline)%>%
  select(ag_profit)%>%
  pull()

storage = storage %>%
    mutate(ag_profit_diff = ag_profit - baseline_ag_profit, 
           profit_farming_diff = profit_farming - baseline_profit_farming, 
           profit_poaching_diff = profit_poaching - baseline_profit_monop,
           profit_fishermen_diff = profit_fishermen - baseline_profit_fishermen)

# Population 
baseline_poaching = storage %>%
  subset(names == 'ss_monop')%>%
  filter(W < 1.1*W_baseline & W>.98*W_baseline)%>%
  filter(W1 < 1.1* W1_baseline & W1 > .98*W1_baseline)%>%
  filter(W2 < 1.1 *W2_baseline & W2_baseline >.98 * W2_baseline)%>%
  select(poached_harvest)%>%
  pull()

baseline_stock = storage %>%
  subset(names == 'ss_monop')%>%
  filter(W < 1.1*W_baseline & W>.98*W_baseline)%>%
  filter(W1 < 1.1* W1_baseline & W1 > .98*W1_baseline)%>%
  filter(W2 < 1.1 *W2_baseline & W2_baseline >.98 * W2_baseline)%>%
  select(x)%>%
  pull()

  
storage['variation_poaching'] = (storage['poached_harvest'] - baseline_poaching)/baseline_poaching*100

storage['normalized_ss'] = (storage['x'] - baseline_stock)/baseline_stock*100

storage_stable = storage%>%
    subset(stability>0)

a = storage_stable %>%
  filter(W < 1.1*W_baseline & W>.98*W_baseline)%>%
  filter(W1 < 1.1* W1_baseline & W1 > .98*W1_baseline)%>%
  filter(W2 < 1.1 *W2_baseline & W2_baseline >.98 * W2_baseline)%>%
  select(-c('stability', 'W', 'W1', 'W2'))

renamer= function(x){
  if(x %in% c('ss_monop', 'ss_monop_lq')){
    rep = 'Vertical Monopoly'
  }else if(x %in% c('ss_cournot', 'ss_cournot_lq')){
    rep = 'Quantity adjustment'
  }else if(x %in% c('ss_bertrand', 'ss_bertrand_lq')){
    rep  = 'Price setting'
  }else if(x %in% c('growth')){
    rep = 'Growth'
  }
  if(length(strsplit(x,'_')[[1]])>2){
    rep = paste0(as.character(rep), ' - LQ cost')
  }
  return(rep)
}

a['names']= sapply(a$names, renamer)

a = a%>%
  mutate(price_buche_final = price_retail / 1000 * avg_toto_weight,
         price_buche_fisher = price_poachers / 1000 * avg_toto_weight)%>%
  relocate(x, .after = farmed_harvest)%>%
  relocate(normalized_ss, .after = profit_fishermen_diff)%>%
  relocate(price_retail, .before = price_poachers)%>%
  relocate(price_buche_final, .after = price_retail)%>%
  relocate(price_buche_fisher, .after = price_poachers)%>%
  relocate(variation_poaching, .after = normalized_ss)%>%
  mutate(normalized_ss = paste0(round(normalized_ss, 2), '%'), 
         variation_poaching = paste0(round(variation_poaching,2), '%'))%>%
  mutate(profit_farming = round(profit_farming/1000000,2),
         poached_harvest = round(poached_harvest, 2), 
         farmed_harvest = round(farmed_harvest, 2),
         profit_fishermen = round(profit_fishermen/1000000,2),
         profit_poaching = round(profit_poaching/1000000,2),
         ag_profit = round(ag_profit/1000000,2),
         profit_farming_diff = round(profit_farming_diff/1000000,2),
         ag_profit_diff = round(ag_profit_diff/1000000,2),
         profit_fishermen_diff = round(profit_fishermen_diff/1000000,2),
         profit_poaching_diff = round(profit_poaching_diff/1000000,2)
         )%>%
  rename('Scenario' = names, 
         'Steady state population (in mt)' = x,
         'Poached harvest (in mt)' = poached_harvest,
         'Farmed harvest (in mt)' = farmed_harvest,
         'Variation in ss. pop.' = normalized_ss,
         'Price  paid to poacher (in USD/ton of buche)' = price_poachers,
         'Retail price (in USD/ton of buche)' = price_retail,
         'Illegal profit (in million USD)'= profit_poaching,
         'Retail price of 500g buche (in USD)' = price_buche_final,
         'Poacher price of 500g buche (in USD)' = price_buche_fisher,
         'Farming profit (in million USD)' = profit_farming, 
         'Fishing profit (in million USD)' = profit_fishermen,
         "Aggregate profit (in million USD)" = ag_profit,
         'Farming profit change (in million USD)' = profit_farming_diff,
         'Aggregate profit change (in million USD)' = ag_profit_diff, 
         'Fishing profit change (in million USD)' = profit_fishermen_diff,
         'Illegal profit change (in million USD)' = profit_poaching_diff,
         'Poaching change (%)' = variation_poaching)

d = rbind(a %>%
            subset(Scenario %in% c('Vertical Monopoly', 
                         'Quantity adjustment', 
                         'Price setting'))%>%
            arrange(desc(Scenario)), 
          a %>%
            subset(Scenario %in% c('Vertical Monopoly - LQ cost', 
                         'Quantity adjustment - LQ cost', 
                         'Price setting - LQ cost'))%>%
            arrange(desc(Scenario)))
          
          
d %>% 
  tt(caption = 'Bioeconomic performance - with baseline specification')%>%
  style_tt(j = 1, background = '#eae4e4')%>%
  style_tt(j = 2:4, background = '#cfe2f3')%>%
  style_tt(j = 5:8, background = '#d5f8c8' )%>%
  style_tt(j = 9:12, background = '#98f7b5' )%>%
  style_tt(j = 17:18, background = '#f4cccc')%>%
  style_tt(i = 0,  background = '#eae4e4')%>%
  style_tt(j = 1, bold = T)

``` 

